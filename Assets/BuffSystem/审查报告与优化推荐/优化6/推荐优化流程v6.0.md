# BuffSystem æ¨èä¼˜åŒ–æµç¨‹ v6.0

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v6.0  
**æ›´æ–°æ—¥æœŸï¼š** 2026-02-12  
**é€‚ç”¨èŒƒå›´ï¼š** BuffSystem v6.x ç‰ˆæœ¬ä¼˜åŒ–  
**å‰ç½®æ¡ä»¶ï¼š** å·²å®Œæˆv1.0-v5.0æ‰€æœ‰ä¼˜åŒ–é¡¹

---

## ç›®å½•

1. [ä¼˜åŒ–æ€»è§ˆ](#ä¼˜åŒ–æ€»è§ˆ)
2. [Phase 1: æ ¸å¿ƒåŠŸèƒ½æ°¸ä¹…åŒ–](#phase-1-æ ¸å¿ƒåŠŸèƒ½æ°¸ä¹…åŒ–)
3. [Phase 2: æ€§èƒ½æè‡´ä¼˜åŒ–](#phase-2-æ€§èƒ½æè‡´ä¼˜åŒ–)
4. [Phase 3: å¼€å‘è€…å·¥å…·é“¾](#phase-3-å¼€å‘è€…å·¥å…·é“¾)
5. [ä¼˜åŒ–å®æ–½æ£€æŸ¥æ¸…å•](#ä¼˜åŒ–å®æ–½æ£€æŸ¥æ¸…å•)
6. [ç‰ˆæœ¬å‘å¸ƒè®¡åˆ’](#ç‰ˆæœ¬å‘å¸ƒè®¡åˆ’)

---

## ä¼˜åŒ–æ€»è§ˆ

### v6.0ä¼˜åŒ–ç›®æ ‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BuffSystem v6.0 ä¼˜åŒ–ç›®æ ‡                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç›®æ ‡ï¼šè¾¾åˆ°100%ç”Ÿäº§å°±ç»ªåº¦ï¼Œæ ¸å¿ƒAPIæ°¸ä¹…ç¨³å®šï¼Œæ€§èƒ½æè‡´ä¼˜åŒ–    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ç¨³å®šç›®æ ‡ï¼šæ ¸å¿ƒAPIå†»ç»“ï¼Œ100%å‘åå…¼å®¹ä¿è¯                    â”‚
â”‚  æ€§èƒ½ç›®æ ‡ï¼šå†…å­˜å‡å°‘60%ï¼ŒCPUä½¿ç”¨å‡å°‘70%ï¼Œé›¶GC Alloc          â”‚
â”‚  åŠŸèƒ½ç›®æ ‡ï¼šä¼ æ’­/èåˆ/ç»§æ‰¿ç³»ç»Ÿï¼Œå®Œæ•´é«˜çº§ç‰¹æ€§                 â”‚
â”‚  ä½“éªŒç›®æ ‡ï¼šå¯è§†åŒ–è°ƒè¯•ï¼Œ8+ç¤ºä¾‹é¡¹ç›®ï¼Œ15åˆ†é’Ÿä¸Šæ‰‹               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### v5.0 â†’ v6.0æ¼”è¿›

| ä¼˜åŒ–é¡¹ | v5.0çŠ¶æ€ | v6.0çŠ¶æ€ | è¯´æ˜ |
|--------|---------|---------|------|
| æ ¸å¿ƒAPIç¨³å®šæ€§ | ğŸŸ¡ åŸºæœ¬ç¨³å®š | ğŸ”’ æ°¸ä¹…å†»ç»“ | å‘åå…¼å®¹ä¿è¯ |
| ç»“æ„ä½“åŒ–ä¼˜åŒ– | â¬œ å¾…å®Œæˆ | ğŸ”µ é«˜ä¼˜å…ˆçº§ | æ€§èƒ½æè‡´ä¼˜åŒ– |
| åˆ†å±‚æ›´æ–°é¢‘ç‡ | â¬œ å¾…å®Œæˆ | ğŸ”µ é«˜ä¼˜å…ˆçº§ | CPUä¼˜åŒ– |
| Buffä¼ æ’­ç³»ç»Ÿ | â¬œ å¾…å®Œæˆ | ğŸ”µ é«˜ä¼˜å…ˆçº§ | é«˜çº§ç‰¹æ€§ |
| Buffèåˆç³»ç»Ÿ | â¬œ å¾…å®Œæˆ | ğŸ”µ é«˜ä¼˜å…ˆçº§ | é«˜çº§ç‰¹æ€§ |
| å¯è§†åŒ–è°ƒè¯•çª—å£ | â¬œ å¾…å®Œæˆ | ğŸ”µ ä¸­ä¼˜å…ˆçº§ | å¼€å‘å·¥å…· |
| å®Œæ•´ç¤ºä¾‹é¡¹ç›® | â¬œ å¾…å®Œæˆ | ğŸ”µ ä¸­ä¼˜å…ˆçº§ | å¼€å‘ä½“éªŒ |

### ä¼˜åŒ–è·¯çº¿å›¾

```
æ—¶é—´çº¿ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º

Phase 1 (2-3å‘¨)      Phase 2 (2-3å‘¨)      Phase 3 (1-2å‘¨)
 æ ¸å¿ƒåŠŸèƒ½æ°¸ä¹…åŒ–        æ€§èƒ½æè‡´ä¼˜åŒ–          å¼€å‘è€…å·¥å…·é“¾
        â–¼                  â–¼                  â–¼
   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚APIå†»ç»“  â”‚   â†’    â”‚ç»“æ„ä½“åŒ– â”‚   â†’    â”‚è°ƒè¯•çª—å£ â”‚
   â”‚ä¼ æ’­ç³»ç»Ÿ â”‚        â”‚åˆ†å±‚æ›´æ–° â”‚        â”‚ç¤ºä¾‹é¡¹ç›®â”‚
   â”‚èåˆç³»ç»Ÿ â”‚        â”‚å†…å­˜ä¼˜åŒ– â”‚        â”‚æ–‡æ¡£å®Œå–„â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Phase 1: æ ¸å¿ƒåŠŸèƒ½æ°¸ä¹…åŒ–

### ğŸ”´ 1.1 æ ¸å¿ƒAPIå†»ç»“ - ç¨³å®šæ€§ä¼˜å…ˆ

**ä¼˜å…ˆçº§ï¼š** ğŸ”´ æé«˜  
**é¢„ä¼°å·¥æ—¶ï¼š** 2-3å¤©  
**å½±å“èŒƒå›´ï¼š** Core/Runtimeå‘½åç©ºé—´  
**çŠ¶æ€ï¼š** â¬œ å¾…å®Œæˆ

#### è®¾è®¡åŸåˆ™

**ä¸ºä»€ä¹ˆè¦å†»ç»“APIï¼Ÿ**
- ç³»ç»Ÿå·²è¾¾åˆ°æˆç†ŸçŠ¶æ€ï¼Œæ ¸å¿ƒåŠŸèƒ½ç¨³å®š
- ä¸ºç”¨æˆ·æä¾›å‘åå…¼å®¹ä¿è¯
- å»ºç«‹è¡Œä¸šæ ‡æ†çº§çš„å¯é æ€§

**å†»ç»“èŒƒå›´ï¼š**
```csharp
// ğŸ”’ æ°¸ä¹…å†»ç»“ï¼ˆåªå…è®¸bugä¿®å¤ï¼‰
BuffSystem.Core/
â”œâ”€â”€ IBuff, IBuffData, IBuffLogic, IEffect, IBuffOwner
â”œâ”€â”€ BuffLogicBase, EffectBase
â””â”€â”€ æ‰€æœ‰æšä¸¾ç±»å‹

BuffSystem.Runtime/
â”œâ”€â”€ BuffOwner, BuffEntity, BuffContainer
â””â”€â”€ BuffApi
```

#### å®æ–½æ­¥éª¤

**æ­¥éª¤1: æ ‡è®°ç¨³å®šAPI**
```csharp
namespace BuffSystem.Core
{
    /// <summary>
    /// Buffå®ä¾‹æ¥å£ - è¿è¡Œæ—¶Buffå®ä½“çš„æŠ½è±¡
    /// </summary>
    /// <remarks>
    /// ğŸ”’ ç¨³å®šAPI: v6.0åä¿è¯å‘åå…¼å®¹
    /// ç‰ˆæœ¬å†å²: v1.0-v6.0 é€æ­¥å®Œå–„
    /// </remarks>
    public interface IBuff
    {
        // ...
    }
}
```

**æ­¥éª¤2: åˆ›å»ºå…¼å®¹æ€§ä¿è¯æ–‡æ¡£**
```markdown
# APIç¨³å®šæ€§ä¿è¯

## v6.0+ å‘åå…¼å®¹æ‰¿è¯º

ä»¥ä¸‹APIåœ¨v6.xã€v7.xã€v8.xä¸­ä¿è¯ä¸å˜ï¼š

### æ ¸å¿ƒæ¥å£
- IBuff (æ‰€æœ‰æˆå‘˜)
- IBuffData (æ‰€æœ‰æˆå‘˜)
- IBuffLogic (æ‰€æœ‰æˆå‘˜)
- IEffect (æ‰€æœ‰æˆå‘˜)
- IBuffOwner (æ‰€æœ‰æˆå‘˜)

### æ ¸å¿ƒç±»
- BuffOwner (å…¬å¼€æ–¹æ³•/å±æ€§)
- BuffEntity (å…¬å¼€æ–¹æ³•/å±æ€§)
- BuffContainer (å…¬å¼€æ–¹æ³•/å±æ€§)
- BuffApi (æ‰€æœ‰é™æ€æ–¹æ³•)

### æšä¸¾
- BuffStackMode
- BuffRemoveMode
- UpdateMode
- BuffEventType

## å¦‚æœå¿…é¡»ä¿®æ”¹

å¦‚æœæœªæ¥ç‰ˆæœ¬å¿…é¡»ä¿®æ”¹ä»¥ä¸ŠAPIï¼š
1. æä¾›[Obsolete]æ ‡è®°çš„å…¼å®¹å±‚
2. è‡³å°‘ä¿ç•™2ä¸ªä¸»ç‰ˆæœ¬
3. æä¾›è‡ªåŠ¨è¿ç§»å·¥å…·
```

---

### ğŸ”´ 1.2 Buffä¼ æ’­ç³»ç»Ÿ - ä¼ æŸ“ä¸æ‰©æ•£

**ä¼˜å…ˆçº§ï¼š** ğŸ”´ é«˜  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-4å¤©  
**å½±å“èŒƒå›´ï¼š** æ–°å¢Transmissionæ–‡ä»¶å¤¹  
**çŠ¶æ€ï¼š** â¬œ å¾…å®Œæˆ

#### è®¾è®¡ç›®æ ‡

æ”¯æŒæ¸¸æˆåœºæ™¯ï¼š
- **ä¼ æŸ“æ€§ç–¾ç—…**ï¼šç˜Ÿç–«ã€ä¸­æ¯’åœ¨æ•Œäººé—´ä¼ æ’­
- **è¿é”ååº”**ï¼šé—ªç”µé“¾ã€è¿é”çˆ†ç‚¸
- **å¢ç›Šæ‰©æ•£**ï¼šå…‰ç¯æ•ˆæœä¼ é€’ç»™é˜Ÿå‹
- **ç¾¤ä½“æ§åˆ¶**ï¼šææƒ§åœ¨æ•Œç¾¤ä¸­è”“å»¶

#### å®ç°æ–¹æ¡ˆ

```csharp
// =====================================================
// Core/IBuffTransmissible.cs
// =====================================================
namespace BuffSystem.Transmission
{
    /// <summary>
    /// Buffä¼ æ’­æ¥å£ - å®ç°æ­¤æ¥å£çš„Buffå¯ä»¥åœ¨å•ä½é—´ä¼ æ’­
    /// </summary>
    public interface IBuffTransmissible
    {
        /// <summary>
        /// ä¼ æ’­æ¨¡å¼
        /// </summary>
        TransmissionMode Mode { get; }
        
        /// <summary>
        /// æ˜¯å¦å¯ä»¥ä¼ æ’­ç»™ç›®æ ‡
        /// </summary>
        bool CanTransmit(IBuff buff, IBuffOwner target);
        
        /// <summary>
        /// è·å–ä¼ æ’­ç›®æ ‡
        /// </summary>
        IEnumerable<IBuffOwner> GetTransmissionTargets(IBuff buff);
        
        /// <summary>
        /// ä¼ æ’­å‘ç”Ÿæ—¶
        /// </summary>
        void OnTransmit(IBuff buff, IBuffOwner from, IBuffOwner to);
        
        /// <summary>
        /// æœ€å¤§ä¼ æ’­é“¾é•¿åº¦
        /// </summary>
        int MaxTransmissionChain { get; }
        
        /// <summary>
        /// å½“å‰ä¼ æ’­é“¾é•¿åº¦
        /// </summary>
        int CurrentChainLength { get; set; }
    }
    
    /// <summary>
    /// ä¼ æ’­æ¨¡å¼
    /// </summary>
    public enum TransmissionMode
    {
        /// <summary>
        /// æ¥è§¦ä¼ æ’­ - ä¸æ„ŸæŸ“è€…æ¥è§¦æ—¶ä¼ æ’­
        /// </summary>
        Contact,
        
        /// <summary>
        /// èŒƒå›´ä¼ æ’­ - èŒƒå›´å†…æ‰€æœ‰ç›®æ ‡
        /// </summary>
        Range,
        
        /// <summary>
        /// é“¾å¼ä¼ æ’­ - ä»ä¸€ä¸ªç›®æ ‡è·³åˆ°å¦ä¸€ä¸ª
        /// </summary>
        Chain,
        
        /// <summary>
        /// ç»§æ‰¿ä¼ æ’­ - åŸæŒæœ‰è€…æ­»äº¡æ—¶è½¬ç§»
        /// </summary>
        Inheritance
    }
}

// =====================================================
// Modes/ContactTransmission.cs
// =====================================================
using System;
using System.Collections.Generic;
using UnityEngine;
using BuffSystem.Core;

namespace BuffSystem.Transmission
{
    /// <summary>
    /// æ¥è§¦ä¼ æ’­ - å½“ä¸¤ä¸ªå•ä½æ¥è§¦æ—¶ä¼ æ’­Buff
    /// </summary>
    [Serializable]
    public class ContactTransmission : IBuffTransmissible
    {
        [Tooltip("ä¼ æ’­æ¦‚ç‡ 0-1")]
        [SerializeField, Range(0f, 1f)]
        private float transmissionProbability = 0.5f;
        
        [Tooltip("ä¼ æ’­å†·å´æ—¶é—´ï¼ˆç§’ï¼‰")]
        [SerializeField]
        private float transmissionCooldown = 1f;
        
        [Tooltip("æ¥è§¦æ£€æµ‹åŠå¾„")]
        [SerializeField]
        private float contactRadius = 2f;
        
        [Tooltip("ç›®æ ‡å±‚")]
        [SerializeField]
        private LayerMask targetLayers = ~0;
        
        [Tooltip("æ˜¯å¦åªå¯¹æ•Œäººç”Ÿæ•ˆ")]
        [SerializeField]
        private bool onlyAffectEnemies = false;
        
        private float lastTransmissionTime;
        
        public TransmissionMode Mode => TransmissionMode.Contact;
        
        public int MaxTransmissionChain => 1; // æ¥è§¦ä¼ æ’­ä¸è¿é”
        
        public int CurrentChainLength { get; set; }
        
        public bool CanTransmit(IBuff buff, IBuffOwner target)
        {
            // æ£€æŸ¥å†·å´
            if (Time.time - lastTransmissionTime < transmissionCooldown)
                return false;
            
            // æ£€æŸ¥æ¦‚ç‡
            if (UnityEngine.Random.value > transmissionProbability)
                return false;
            
            // æ£€æŸ¥å…ç–«
            if (target.IsImmuneTo(buff.DataId))
                return false;
            
            return true;
        }
        
        public IEnumerable<IBuffOwner> GetTransmissionTargets(IBuff buff)
        {
            if (buff.Owner is not MonoBehaviour ownerMono)
                yield break;
            
            Vector3 position = ownerMono.transform.position;
            
            // æ£€æµ‹èŒƒå›´å†…ç¢°æ’ä½“
            Collider[] colliders = Physics.OverlapSphere(position, contactRadius, targetLayers);
            
            foreach (var collider in colliders)
            {
                var targetOwner = collider.GetComponent<IBuffOwner>();
                if (targetOwner == null || targetOwner == buff.Owner)
                    continue;
                
                // é˜µè¥æ£€æŸ¥
                if (onlyAffectEnemies && !IsEnemy(buff.Owner, targetOwner))
                    continue;
                
                yield return targetOwner;
            }
        }
        
        public void OnTransmit(IBuff buff, IBuffOwner from, IBuffOwner to)
        {
            lastTransmissionTime = Time.time;
            
            // ä¼ æ’­Buff
            to.BuffContainer.AddBuff(buff.Data, from);
            
            // è§¦å‘äº‹ä»¶
            TransmissionEventSystem.TriggerTransmitted(buff, from, to, Mode);
            
            if (BuffSystemConfig.Instance.EnableDebugLog)
            {
                Debug.Log($"[ContactTransmission] Buff {buff.Name} ä» {from.OwnerName} ä¼ æ’­åˆ° {to.OwnerName}");
            }
        }
        
        private bool IsEnemy(IBuffOwner a, IBuffOwner b)
        {
            // é€šè¿‡äº‹ä»¶ç³»ç»Ÿè®©æ¸¸æˆç«¯åˆ¤æ–­é˜µè¥
            return TransmissionEventSystem.CheckIsEnemy(a, b);
        }
    }
}

// =====================================================
// Modes/ChainTransmission.cs - é—ªç”µé“¾æ•ˆæœ
// =====================================================
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using BuffSystem.Core;

namespace BuffSystem.Transmission
{
    /// <summary>
    /// é“¾å¼ä¼ æ’­ - åƒé—ªç”µé“¾ä¸€æ ·åœ¨ç›®æ ‡é—´è·³è·ƒ
    /// </summary>
    [Serializable]
    public class ChainTransmission : IBuffTransmissible
    {
        [Tooltip("æœ€å¤§è·³è·ƒæ¬¡æ•°")]
        [SerializeField]
        private int maxJumps = 3;
        
        [Tooltip("æ¯æ¬¡è·³è·ƒçš„èŒƒå›´")]
        [SerializeField]
        private float jumpRange = 5f;
        
        [Tooltip("æ¯æ¬¡è·³è·ƒçš„è¡°å‡æ¯”ä¾‹")]
        [SerializeField, Range(0f, 1f)]
        private float decayPerJump = 0.7f;
        
        [Tooltip("ç›®æ ‡å±‚")]
        [SerializeField]
        private LayerMask targetLayers = ~0;
        
        [Tooltip("æ˜¯å¦ä¼˜å…ˆé€‰æ‹©æœ€è¿‘ç›®æ ‡")]
        [SerializeField]
        private bool preferNearest = true;
        
        public TransmissionMode Mode => TransmissionMode.Chain;
        
        public int MaxTransmissionChain => maxJumps;
        
        public int CurrentChainLength { get; set; }
        
        public bool CanTransmit(IBuff buff, IBuffOwner target)
        {
            if (CurrentChainLength >= maxJumps)
                return false;
            
            if (target.IsImmuneTo(buff.DataId))
                return false;
            
            return true;
        }
        
        public IEnumerable<IBuffOwner> GetTransmissionTargets(IBuff buff)
        {
            if (buff.Owner is not MonoBehaviour ownerMono)
                yield break;
            
            Vector3 position = ownerMono.transform.position;
            
            // æŸ¥æ‰¾èŒƒå›´å†…æ‰€æœ‰æœ‰æ•ˆç›®æ ‡
            var targets = Physics.OverlapSphere(position, jumpRange, targetLayers)
                .Select(c => c.GetComponent<IBuffOwner>())
                .Where(o => o != null && o != buff.Owner)
                .Where(o => !o.IsImmuneTo(buff.DataId))
                .ToList();
            
            if (preferNearest)
            {
                targets = targets
                    .OrderBy(t => Vector3.Distance(position, (t as MonoBehaviour).transform.position))
                    .ToList();
            }
            
            // åªè¿”å›ç¬¬ä¸€ä¸ªç›®æ ‡ï¼ˆé“¾å¼ä¼ æ’­ä¸€æ¬¡ä¸€ä¸ªï¼‰
            if (targets.Count > 0)
            {
                yield return targets[0];
            }
        }
        
        public void OnTransmit(IBuff buff, IBuffOwner from, IBuffOwner to)
        {
            CurrentChainLength++;
            
            // åº”ç”¨è¡°å‡
            float decayMultiplier = Mathf.Pow(decayPerJump, CurrentChainLength);
            
            // æ·»åŠ Buffï¼ˆå¸¦è¡°å‡å‚æ•°ï¼‰
            var newBuff = to.BuffContainer.AddBuff(buff.Data, from);
            if (newBuff != null)
            {
                // é€šè¿‡äº‹ä»¶ä¼ é€’è¡°å‡ä¿¡æ¯
                var eventData = new ChainTransmissionEventData
                {
                    Buff = newBuff,
                    ChainLength = CurrentChainLength,
                    DecayMultiplier = decayMultiplier
                };
                TransmissionEventSystem.TriggerChainJumped(eventData);
            }
            
            TransmissionEventSystem.TriggerTransmitted(buff, from, to, Mode);
        }
    }
    
    public class ChainTransmissionEventData
    {
        public IBuff Buff { get; set; }
        public int ChainLength { get; set; }
        public float DecayMultiplier { get; set; }
    }
}

// =====================================================
// TransmissionManager.cs - ä¼ æ’­ç®¡ç†å™¨
// =====================================================
using System.Collections.Generic;
using UnityEngine;
using BuffSystem.Core;

namespace BuffSystem.Transmission
{
    /// <summary>
    /// ä¼ æ’­ç®¡ç†å™¨ - ç®¡ç†æ‰€æœ‰Buffçš„ä¼ æ’­é€»è¾‘
    /// </summary>
    public class TransmissionManager : MonoBehaviour
    {
        private static TransmissionManager instance;
        public static TransmissionManager Instance
        {
            get
            {
                if (instance == null)
                {
                    var go = new GameObject("TransmissionManager");
                    instance = go.AddComponent<TransmissionManager>();
                    DontDestroyOnLoad(go);
                }
                return instance;
            }
        }
        
        // å¾…å¤„ç†çš„ä¼ æ’­è¯·æ±‚é˜Ÿåˆ—
        private Queue<TransmissionRequest> transmissionQueue = new();
        
        private void Update()
        {
            ProcessTransmissionQueue();
        }
        
        /// <summary>
        /// è¯·æ±‚ä¼ æ’­æ£€æŸ¥
        /// </summary>
        public void RequestTransmission(IBuff buff)
        {
            if (buff.Data.CreateLogic() is not IBuffTransmissible transmissible)
                return;
            
            transmissionQueue.Enqueue(new TransmissionRequest
            {
                Buff = buff,
                Transmissible = transmissible
            });
        }
        
        private void ProcessTransmissionQueue()
        {
            int processCount = 0;
            int maxPerFrame = BuffSystemConfig.Instance.TransmissionMaxPerFrame;
            
            while (transmissionQueue.Count > 0 && processCount < maxPerFrame)
            {
                var request = transmissionQueue.Dequeue();
                ProcessTransmission(request);
                processCount++;
            }
        }
        
        private void ProcessTransmission(TransmissionRequest request)
        {
            var buff = request.Buff;
            var transmissible = request.Transmissible;
            
            foreach (var target in transmissible.GetTransmissionTargets(buff))
            {
                if (transmissible.CanTransmit(buff, target))
                {
                    transmissible.OnTransmit(buff, buff.Owner, target);
                    
                    // é“¾å¼ä¼ æ’­éœ€è¦ç»§ç»­ä¼ æ’­æ–°Buff
                    if (transmissible.Mode == TransmissionMode.Chain && 
                        transmissible.CurrentChainLength < transmissible.MaxTransmissionChain)
                    {
                        var newBuff = target.BuffContainer.GetBuffByDataId(buff.DataId);
                        if (newBuff != null)
                        {
                            RequestTransmission(newBuff);
                        }
                    }
                }
            }
        }
        
        private class TransmissionRequest
        {
            public IBuff Buff;
            public IBuffTransmissible Transmissible;
        }
    }
}
```

---

### ğŸ”´ 1.3 Buffèåˆç³»ç»Ÿ - å…ƒç´ ååº”ä¸åˆæˆ

**ä¼˜å…ˆçº§ï¼š** ğŸ”´ é«˜  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-4å¤©  
**å½±å“èŒƒå›´ï¼š** æ–°å¢Fusionæ–‡ä»¶å¤¹  
**çŠ¶æ€ï¼š** â¬œ å¾…å®Œæˆ

#### è®¾è®¡ç›®æ ‡

æ”¯æŒæ¸¸æˆåœºæ™¯ï¼š
- **å…ƒç´ ååº”**ï¼šç«+å†°=èåŒ–ï¼Œç«+é›·=è¶…è½½
- **æŠ€èƒ½åˆæˆ**ï¼šæŠ€èƒ½A+æŠ€èƒ½B=ç»ˆææŠ€èƒ½
- **Buffè¿›åŒ–**ï¼šä½çº§Buffèåˆæˆé«˜çº§Buff
- **é…æ–¹åˆ¶ä½œ**ï¼šæ”¶é›†ææ–™åˆ¶ä½œæ–°Buff

#### å®ç°æ–¹æ¡ˆ

```csharp
// =====================================================
// Core/IBuffFusion.cs
// =====================================================
namespace BuffSystem.Fusion
{
    /// <summary>
    /// Buffèåˆæ¥å£ - å®ç°æ­¤æ¥å£çš„Buffå¯ä»¥å‚ä¸èåˆ
    /// </summary>
    public interface IBuffFusion
    {
        /// <summary>
        /// èåˆé…æ–¹ID
        /// </summary>
        string RecipeId { get; }
        
        /// <summary>
        /// æ˜¯å¦å¯ä»¥èåˆ
        /// </summary>
        bool CanFuse(IBuffContainer container);
        
        /// <summary>
        /// æ‰§è¡Œèåˆ
        /// </summary>
        /// <returns>èåˆç»“æœBuff</returns>
        IBuff Fuse(IBuffContainer container);
        
        /// <summary>
        /// èåˆå‰å›è°ƒ
        /// </summary>
        void OnBeforeFusion(IBuffContainer container);
        
        /// <summary>
        /// èåˆåå›è°ƒ
        /// </summary>
        void OnAfterFusion(IBuffContainer container, IBuff resultBuff);
    }
    
    /// <summary>
    /// èåˆé…æ–¹
    /// </summary>
    [Serializable]
    public class FusionRecipe
    {
        [Tooltip("é…æ–¹å”¯ä¸€ID")]
        public string recipeId;
        
        [Tooltip("é…æ–¹åç§°")]
        public string recipeName;
        
        [Tooltip("æ‰€éœ€Buffåˆ—è¡¨")]
        public List<Ingredient> ingredients = new();
        
        [Tooltip("èåˆç»“æœBuff ID")]
        public int resultBuffId;
        
        [Tooltip("èåˆæ—¶é—´ï¼ˆç§’ï¼‰")]
        public float fusionTime;
        
        [Tooltip("èåˆæ¡ä»¶")]
        [SerializeReference]
        public List<IFusionCondition> conditions = new();
        
        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦æ»¡è¶³èåˆæ¡ä»¶
        /// </summary>
        public bool CheckConditions(IBuffContainer container)
        {
            foreach (var condition in conditions)
            {
                if (!condition.Check(container, this))
                    return false;
            }
            return true;
        }
        
        /// <summary>
        /// æ£€æŸ¥æ˜¯å¦æœ‰æ‰€éœ€ææ–™
        /// </summary>
        public bool HasIngredients(IBuffContainer container)
        {
            foreach (var ingredient in ingredients)
            {
                int count = container.GetBuffCountById(ingredient.buffId);
                if (count < ingredient.requiredCount)
                    return false;
            }
            return true;
        }
    }
    
    /// <summary>
    /// èåˆææ–™
    /// </summary>
    [Serializable]
    public class Ingredient
    {
        [Tooltip("Buff ID")]
        public int buffId;
        
        [Tooltip("æ‰€éœ€æ•°é‡")]
        public int requiredCount = 1;
        
        [Tooltip("æ˜¯å¦æ¶ˆè€—")]
        public bool consume = true;
    }
    
    /// <summary>
    /// èåˆæ¡ä»¶æ¥å£
    /// </summary>
    public interface IFusionCondition
    {
        bool Check(IBuffContainer container, FusionRecipe recipe);
        string Description { get; }
    }
}

// =====================================================
// FusionManager.cs - èåˆç®¡ç†å™¨
// =====================================================
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using BuffSystem.Core;

namespace BuffSystem.Fusion
{
    /// <summary>
    /// èåˆç®¡ç†å™¨ - ç®¡ç†æ‰€æœ‰èåˆé…æ–¹å’Œæ‰§è¡Œ
    /// </summary>
    public class FusionManager : MonoBehaviour
    {
        private static FusionManager instance;
        public static FusionManager Instance
        {
            get
            {
                if (instance == null)
                {
                    var go = new GameObject("FusionManager");
                    instance = go.AddComponent<FusionManager>();
                    DontDestroyOnLoad(go);
                }
                return instance;
            }
        }
        
        // é…æ–¹æ³¨å†Œè¡¨
        private Dictionary<string, FusionRecipe> recipes = new();
        
        // è¿›è¡Œä¸­çš„èåˆ
        private List<ActiveFusion> activeFusions = new();
        
        /// <summary>
        /// æ³¨å†Œé…æ–¹
        /// </summary>
        public void RegisterRecipe(FusionRecipe recipe)
        {
            if (string.IsNullOrEmpty(recipe.recipeId))
            {
                Debug.LogError("[FusionManager] é…æ–¹IDä¸èƒ½ä¸ºç©º");
                return;
            }
            
            recipes[recipe.recipeId] = recipe;
            
            if (BuffSystemConfig.Instance.EnableDebugLog)
            {
                Debug.Log($"[FusionManager] æ³¨å†Œé…æ–¹: {recipe.recipeName} ({recipe.recipeId})");
            }
        }
        
        /// <summary>
        /// å°è¯•èåˆ
        /// </summary>
        public bool TryFusion(string recipeId, IBuffContainer container, out IBuff resultBuff)
        {
            resultBuff = null;
            
            if (!recipes.TryGetValue(recipeId, out var recipe))
            {
                Debug.LogError($"[FusionManager] æœªæ‰¾åˆ°é…æ–¹: {recipeId}");
                return false;
            }
            
            // æ£€æŸ¥ææ–™
            if (!recipe.HasIngredients(container))
            {
                Debug.Log($"[FusionManager] ææ–™ä¸è¶³ï¼Œæ— æ³•èåˆ: {recipe.recipeName}");
                return false;
            }
            
            // æ£€æŸ¥æ¡ä»¶
            if (!recipe.CheckConditions(container))
            {
                Debug.Log($"[FusionManager] æ¡ä»¶ä¸æ»¡è¶³ï¼Œæ— æ³•èåˆ: {recipe.recipeName}");
                return false;
            }
            
            // å¼€å§‹èåˆ
            if (recipe.fusionTime > 0)
            {
                // å»¶è¿Ÿèåˆ
                StartDelayedFusion(recipe, container);
                return true;
            }
            else
            {
                // ç«‹å³èåˆ
                resultBuff = ExecuteFusion(recipe, container);
                return resultBuff != null;
            }
        }
        
        /// <summary>
        /// è‡ªåŠ¨æ£€æµ‹å¯èåˆçš„é…æ–¹
        /// </summary>
        public List<FusionRecipe> GetAvailableFusions(IBuffContainer container)
        {
            var available = new List<FusionRecipe>();
            
            foreach (var recipe in recipes.Values)
            {
                if (recipe.HasIngredients(container) && recipe.CheckConditions(container))
                {
                    available.Add(recipe);
                }
            }
            
            return available;
        }
        
        private void StartDelayedFusion(FusionRecipe recipe, IBuffContainer container)
        {
            var activeFusion = new ActiveFusion
            {
                Recipe = recipe,
                Container = container,
                RemainingTime = recipe.fusionTime,
                TotalTime = recipe.fusionTime
            };
            
            activeFusions.Add(activeFusion);
            
            // è§¦å‘èåˆå¼€å§‹äº‹ä»¶
            FusionEventSystem.TriggerFusionStarted(recipe, container);
        }
        
        private IBuff ExecuteFusion(FusionRecipe recipe, IBuffContainer container)
        {
            // æ¶ˆè€—ææ–™
            foreach (var ingredient in recipe.ingredients)
            {
                if (ingredient.consume)
                {
                    for (int i = 0; i < ingredient.requiredCount; i++)
                    {
                        container.RemoveBuffById(ingredient.buffId);
                    }
                }
            }
            
            // åˆ›å»ºç»“æœBuff
            var resultData = BuffDatabase.Instance.GetBuffData(recipe.resultBuffId);
            if (resultData == null)
            {
                Debug.LogError($"[FusionManager] æœªæ‰¾åˆ°ç»“æœBuff: {recipe.resultBuffId}");
                return null;
            }
            
            var resultBuff = container.AddBuff(resultData, this);
            
            // è§¦å‘èåˆå®Œæˆäº‹ä»¶
            FusionEventSystem.TriggerFusionCompleted(recipe, container, resultBuff);
            
            if (BuffSystemConfig.Instance.EnableDebugLog)
            {
                Debug.Log($"[FusionManager] èåˆæˆåŠŸ: {recipe.recipeName} -> {resultBuff.Name}");
            }
            
            return resultBuff;
        }
        
        private void Update()
        {
            // æ›´æ–°è¿›è¡Œä¸­çš„èåˆ
            for (int i = activeFusions.Count - 1; i >= 0; i--)
            {
                var fusion = activeFusions[i];
                fusion.RemainingTime -= Time.deltaTime;
                
                // è§¦å‘è¿›åº¦æ›´æ–°
                float progress = 1f - (fusion.RemainingTime / fusion.TotalTime);
                FusionEventSystem.TriggerFusionProgress(fusion.Recipe, fusion.Container, progress);
                
                if (fusion.RemainingTime <= 0)
                {
                    // èåˆå®Œæˆ
                    ExecuteFusion(fusion.Recipe, fusion.Container);
                    activeFusions.RemoveAt(i);
                }
            }
        }
        
        private class ActiveFusion
        {
            public FusionRecipe Recipe;
            public IBuffContainer Container;
            public float RemainingTime;
            public float TotalTime;
        }
    }
}
```

---

## Phase 2: æ€§èƒ½æè‡´ä¼˜åŒ–

### ğŸ”´ 2.1 ç»“æ„ä½“åŒ–æ”¹é€  - å†…å­˜ä¼˜åŒ–æ ¸å¿ƒ

**ä¼˜å…ˆçº§ï¼š** ğŸ”´ æé«˜  
**é¢„ä¼°å·¥æ—¶ï¼š** 5-7å¤©  
**å½±å“èŒƒå›´ï¼š** Runtimeæ ¸å¿ƒç±»é‡æ„  
**çŠ¶æ€ï¼š** â¬œ å¾…å®Œæˆ

#### ä¼˜åŒ–ç›®æ ‡

| æŒ‡æ ‡ | å½“å‰ | ç›®æ ‡ | ä¼˜åŒ–å¹…åº¦ |
|------|------|------|---------|
| Buffå†…å­˜å ç”¨ | ~200 bytes | ~32 bytes | â¬‡ï¸ 84% |
| å †åˆ†é… | æœ‰ | é›¶ | â¬‡ï¸ 100% |
| ç¼“å­˜å‘½ä¸­ç‡ | ä¸­ | é«˜ | â¬†ï¸ æ˜¾è‘— |
| GCå‹åŠ› | ä½ | é›¶ | â¬‡ï¸ 100% |

#### å®ç°æ–¹æ¡ˆ

```csharp
// =====================================================
// Runtime/BuffData.cs - ç»“æ„ä½“åŒ–Buffæ•°æ®
// =====================================================
using System;
using UnityEngine;

namespace BuffSystem.Runtime
{
    /// <summary>
    /// Buffæ•°æ®ç»“æ„ä½“ - æè‡´å†…å­˜ä¼˜åŒ–
    /// æ€»å¤§å°: 32 bytesï¼Œå¯æ”¾å…¥ä¸€ä¸ªç¼“å­˜è¡Œ
    /// </summary>
    public struct BuffData : IEquatable<BuffData>
    {
        // æ ‡è¯† (8 bytes)
        public int InstanceId;      // 4 bytes
        public int DataId;          // 4 bytes
        
        // å±‚æ•° (4 bytes)
        public short CurrentStack;  // 2 bytes
        public short MaxStack;      // 2 bytes
        
        // æ—¶é—´ (8 bytes)
        public float Duration;      // 4 bytes
        public float TotalDuration; // 4 bytes
        
        // å…³è”ID (8 bytes)
        public int OwnerId;         // 4 bytes
        public int SourceId;        // 4 bytes
        
        // çŠ¶æ€æ ‡å¿— (4 bytes)
        public BuffFlags Flags;     // 4 bytes
        
        // æ€»è®¡: 32 bytes
        
        // å±æ€§è®¿é—®å™¨
        public bool IsActive => (Flags & BuffFlags.IsActive) != 0;
        public bool IsPermanent => (Flags & BuffFlags.IsPermanent) != 0;
        public bool IsMarkedForRemoval => (Flags & BuffFlags.IsMarkedForRemoval) != 0;
        public float RemainingTime => IsPermanent ? float.MaxValue : Mathf.Max(0, TotalDuration - Duration);
        
        public void MarkForRemoval()
        {
            Flags |= BuffFlags.IsMarkedForRemoval;
        }
        
        public void SetActive(bool active)
        {
            if (active)
                Flags |= BuffFlags.IsActive;
            else
                Flags &= ~BuffFlags.IsActive;
        }
        
        public bool Equals(BuffData other)
        {
            return InstanceId == other.InstanceId;
        }
        
        public override int GetHashCode()
        {
            return InstanceId;
        }
    }
    
    /// <summary>
    /// BuffçŠ¶æ€æ ‡å¿—
    /// </summary>
    [Flags]
    public enum BuffFlags : uint
    {
        None = 0,
        IsActive = 1 << 0,
        IsPermanent = 1 << 1,
        IsMarkedForRemoval = 1 << 2,
        CanRefresh = 1 << 3,
        IsUnique = 1 << 4,
        UseVisualUpdate = 1 << 5,
    }
}

// =====================================================
// Runtime/BuffContainer.Struct.cs - ç»“æ„ä½“å­˜å‚¨å®¹å™¨
// =====================================================
using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using BuffSystem.Core;

namespace BuffSystem.Runtime
{
    /// <summary>
    /// é«˜æ€§èƒ½Buffå®¹å™¨ - ä½¿ç”¨ç»“æ„ä½“+NativeArray
    /// </summary>
    public unsafe class BuffContainerOptimized : IBuffContainer
    {
        // ä½¿ç”¨NativeArrayå®ç°é›¶GCã€é«˜æ€§èƒ½
        private NativeArray<BuffData> buffArray;
        private NativeList<int> freeIndices;      // ç©ºé—²æ§½ä½
        private NativeList<int> activeIndices;    // æ´»è·ƒæ§½ä½
        
        // å®¹é‡ç®¡ç†
        private int capacity;
        private const int DefaultCapacity = 32;
        private const int MaxCapacity = 1024;
        
        // ç´¢å¼•æ˜ å°„ (ç”¨äºå¿«é€ŸæŸ¥è¯¢)
        private Dictionary<int, int> instanceIdToIndex;  // InstanceId -> ArrayIndex
        private Dictionary<int, List<int>> dataIdToIndices; // DataId -> ArrayIndices
        
        public IBuffOwner Owner { get; }
        
        public int Count => activeIndices.Length;
        
        public BuffContainerOptimized(IBuffOwner owner, int initialCapacity = DefaultCapacity)
        {
            Owner = owner ?? throw new ArgumentNullException(nameof(owner));
            capacity = Mathf.Clamp(initialCapacity, DefaultCapacity, MaxCapacity);
            
            // åˆå§‹åŒ–Nativeå®¹å™¨
            buffArray = new NativeArray<BuffData>(capacity, Allocator.Persistent);
            freeIndices = new NativeList<int>(capacity, Allocator.Persistent);
            activeIndices = new NativeList<int>(capacity, Allocator.Persistent);
            
            // åˆå§‹åŒ–ç´¢å¼•æ˜ å°„
            instanceIdToIndex = new Dictionary<int, int>(capacity);
            dataIdToIndices = new Dictionary<int, List<int>>(capacity);
            
            // åˆå§‹åŒ–æ‰€æœ‰æ§½ä½ä¸ºç©ºé—²
            for (int i = 0; i < capacity; i++)
            {
                freeIndices.Add(i);
            }
        }
        
        /// <summary>
        /// æ·»åŠ Buff - O(1) amortized
        /// </summary>
        public IBuff AddBuff(IBuffData data, object source = null)
        {
            if (data == null) return null;
            
            // è·å–ç©ºé—²æ§½ä½
            int index = AcquireSlot();
            if (index < 0)
            {
                Debug.LogError("[BuffContainerOptimized] å®¹é‡ä¸è¶³");
                return null;
            }
            
            // åˆ›å»ºBuffæ•°æ®
            var buffData = new BuffData
            {
                InstanceId = GenerateInstanceId(),
                DataId = data.Id,
                CurrentStack = (short)data.AddStackCount,
                MaxStack = (short)data.MaxStack,
                Duration = 0f,
                TotalDuration = data.Duration,
                OwnerId = Owner.OwnerId,
                SourceId = source?.GetHashCode() ?? 0,
                Flags = BuildFlags(data)
            };
            
            // å­˜å‚¨
            buffArray[index] = buffData;
            activeIndices.Add(index);
            
            // æ›´æ–°ç´¢å¼•
            instanceIdToIndex[buffData.InstanceId] = index;
            if (!dataIdToIndices.TryGetValue(data.Id, out var indices))
            {
                indices = new List<int>();
                dataIdToIndices[data.Id] = indices;
            }
            indices.Add(index);
            
            // è¿”å›åŒ…è£…å™¨
            return new BuffDataWrapper(this, index);
        }
        
        /// <summary>
        /// æ›´æ–°æ‰€æœ‰Buff - æ‰¹é‡å¤„ç†ï¼Œç¼“å­˜å‹å¥½
        /// </summary>
        public void Update(float deltaTime)
        {
            var indices = activeIndices.AsArray();
            
            // æ‰¹é‡æ›´æ–° - é¡ºåºè®¿é—®ï¼Œç¼“å­˜å‹å¥½
            for (int i = 0; i < indices.Length; i++)
            {
                int index = indices[i];
                var buff = buffArray[index];
                
                if (!buff.IsActive || buff.IsMarkedForRemoval)
                    continue;
                
                // æ›´æ–°æŒç»­æ—¶é—´
                if (!buff.IsPermanent)
                {
                    buff.Duration += deltaTime;
                    
                    if (buff.Duration >= buff.TotalDuration)
                    {
                        buff.MarkForRemoval();
                    }
                }
                
                buffArray[index] = buff;
            }
            
            // æ¸…ç†æ ‡è®°ç§»é™¤çš„Buff
            CleanupRemovedBuffs();
        }
        
        /// <summary>
        /// è·å–Buff - O(1)
        /// </summary>
        public IBuff GetBuff(int instanceId)
        {
            if (instanceIdToIndex.TryGetValue(instanceId, out int index))
            {
                return new BuffDataWrapper(this, index);
            }
            return null;
        }
        
        /// <summary>
        /// é‡Šæ”¾èµ„æº
        /// </summary>
        public void Dispose()
        {
            if (buffArray.IsCreated) buffArray.Dispose();
            if (freeIndices.IsCreated) freeIndices.Dispose();
            if (activeIndices.IsCreated) activeIndices.Dispose();
        }
        
        private int AcquireSlot()
        {
            // ä¼˜å…ˆä½¿ç”¨ç©ºé—²æ§½ä½
            if (freeIndices.Length > 0)
            {
                int lastIndex = freeIndices.Length - 1;
                int slot = freeIndices[lastIndex];
                freeIndices.RemoveAt(lastIndex);
                return slot;
            }
            
            // éœ€è¦æ‰©å®¹
            if (capacity < MaxCapacity)
            {
                int oldCapacity = capacity;
                capacity = Mathf.Min(capacity * 2, MaxCapacity);
                
                // æ‰©å®¹NativeArray
                var newArray = new NativeArray<BuffData>(capacity, Allocator.Persistent);
                NativeArray<BuffData>.Copy(buffArray, newArray, oldCapacity);
                buffArray.Dispose();
                buffArray = newArray;
                
                // æ·»åŠ æ–°æ§½ä½åˆ°ç©ºé—²åˆ—è¡¨
                for (int i = oldCapacity; i < capacity; i++)
                {
                    freeIndices.Add(i);
                }
                
                return AcquireSlot();
            }
            
            return -1; // å®¹é‡ä¸è¶³
        }
        
        private void CleanupRemovedBuffs()
        {
            for (int i = activeIndices.Length - 1; i >= 0; i--)
            {
                int index = activeIndices[i];
                var buff = buffArray[index];
                
                if (buff.IsMarkedForRemoval)
                {
                    // ç§»é™¤æ´»è·ƒç´¢å¼•
                    activeIndices.RemoveAtSwapBack(i);
                    
                    // æ·»åŠ åˆ°ç©ºé—²åˆ—è¡¨
                    freeIndices.Add(index);
                    
                    // æ¸…ç†ç´¢å¼•æ˜ å°„
                    instanceIdToIndex.Remove(buff.InstanceId);
                    if (dataIdToIndices.TryGetValue(buff.DataId, out var indices))
                    {
                        indices.Remove(index);
                    }
                }
            }
        }
        
        private static int globalInstanceId;
        private static int GenerateInstanceId() => ++globalInstanceId;
        
        private static BuffFlags BuildFlags(IBuffData data)
        {
            BuffFlags flags = BuffFlags.IsActive;
            if (data.IsPermanent) flags |= BuffFlags.IsPermanent;
            if (data.CanRefresh) flags |= BuffFlags.CanRefresh;
            if (data.IsUnique) flags |= BuffFlags.IsUnique;
            return flags;
        }
        
        // BuffDataåŒ…è£…å™¨ - æä¾›IBuffæ¥å£
        private class BuffDataWrapper : IBuff
        {
            private readonly BuffContainerOptimized container;
            private readonly int index;
            
            public BuffDataWrapper(BuffContainerOptimized container, int index)
            {
                this.container = container;
                this.index = index;
            }
            
            private ref BuffData Data => ref container.buffArray.ElementAt(index);
            
            public int InstanceId => Data.InstanceId;
            public int DataId => Data.DataId;
            public string Name => BuffDatabase.Instance.GetBuffData(DataId)?.Name ?? "Unknown";
            public int CurrentStack => Data.CurrentStack;
            public int MaxStack => Data.MaxStack;
            public float Duration => Data.Duration;
            public float TotalDuration => Data.TotalDuration;
            public float RemainingTime => Data.RemainingTime;
            public bool IsPermanent => Data.IsPermanent;
            public bool IsMarkedForRemoval => Data.IsMarkedForRemoval;
            public bool IsActive => Data.IsActive;
            public object Source => null; // éœ€è¦é¢å¤–å­˜å‚¨
            public int SourceId => Data.SourceId;
            public IBuffOwner Owner => container.Owner;
            public IBuffData Data => BuffDatabase.Instance.GetBuffData(DataId);
            
            public void AddStack(int amount)
            {
                var data = Data;
                data.CurrentStack = (short)Mathf.Min(data.CurrentStack + amount, data.MaxStack);
                Data = data;
            }
            
            public void RemoveStack(int amount)
            {
                var data = Data;
                data.CurrentStack = (short)Mathf.Max(data.CurrentStack - amount, 0);
                if (data.CurrentStack <= 0)
                {
                    data.MarkForRemoval();
                }
                Data = data;
            }
            
            public void RefreshDuration()
            {
                var data = Data;
                data.Duration = 0f;
                Data = data;
            }
            
            public void MarkForRemoval()
            {
                var data = Data;
                data.MarkForRemoval();
                Data = data;
            }
        }
    }
}
```

---

### ğŸŸ¡ 2.2 åˆ†å±‚æ›´æ–°é¢‘ç‡ - CPUä¼˜åŒ–

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 2-3å¤©  
**å½±å“èŒƒå›´ï¼š** BuffSystemUpdaterã€BuffContainer  
**çŠ¶æ€ï¼š** â¬œ å¾…å®Œæˆ

#### å®ç°æ–¹æ¡ˆ

```csharp
// =====================================================
// Data/UpdateFrequency.cs
// =====================================================
namespace BuffSystem.Data
{
    /// <summary>
    /// Buffæ›´æ–°é¢‘ç‡
    /// </summary>
    public enum UpdateFrequency
    {
        /// <summary>
        /// æ¯å¸§æ›´æ–° - ç”¨äºè§†è§‰æ•ˆæœ
        /// </summary>
        EveryFrame = 0,
        
        /// <summary>
        /// 30fpsæ›´æ–° - é«˜é¢‘é€»è¾‘
        /// </summary>
        Every33ms = 1,
        
        /// <summary>
        /// 10fpsæ›´æ–° - ä¸­é¢‘é€»è¾‘
        /// </summary>
        Every100ms = 2,
        
        /// <summary>
        /// 2fpsæ›´æ–° - ä½é¢‘é€»è¾‘
        /// </summary>
        Every500ms = 3,
        
        /// <summary>
        /// äº‹ä»¶é©±åŠ¨ - ä¸è‡ªåŠ¨æ›´æ–°
        /// </summary>
        OnEventOnly = 4
    }
}

// =====================================================
// Runtime/BuffSystemUpdater.Frequency.cs
// =====================================================
using System.Collections.Generic;
using UnityEngine;
using BuffSystem.Data;

namespace BuffSystem.Runtime
{
    /// <summary>
    /// åˆ†å±‚é¢‘ç‡æ›´æ–°å™¨
    /// </summary>
    public class FrequencyBasedUpdater
    {
        // æ—¶é—´ç´¯ç§¯å™¨
        private float accumulator33ms;
        private float accumulator100ms;
        private float accumulator500ms;
        
        // æŒ‰é¢‘ç‡åˆ†ç»„çš„å®¹å™¨
        private readonly List<IBuffContainer>[] frequencyBuckets;
        
        public FrequencyBasedUpdater()
        {
            frequencyBuckets = new List<IBuffContainer>[5];
            for (int i = 0; i < 5; i++)
            {
                frequencyBuckets[i] = new List<IBuffContainer>();
            }
        }
        
        public void Register(IBuffContainer container, UpdateFrequency frequency)
        {
            frequencyBuckets[(int)frequency].Add(container);
        }
        
        public void Unregister(IBuffContainer container)
        {
            foreach (var bucket in frequencyBuckets)
            {
                bucket.Remove(container);
            }
        }
        
        public void Update(float deltaTime)
        {
            // æ¯å¸§æ›´æ–° (60fps)
            UpdateBucket(UpdateFrequency.EveryFrame, deltaTime);
            
            // 33msæ›´æ–° (~30fps)
            accumulator33ms += deltaTime;
            if (accumulator33ms >= 0.033f)
            {
                UpdateBucket(UpdateFrequency.Every33ms, accumulator33ms);
                accumulator33ms = 0f;
            }
            
            // 100msæ›´æ–° (10fps)
            accumulator100ms += deltaTime;
            if (accumulator100ms >= 0.1f)
            {
                UpdateBucket(UpdateFrequency.Every100ms, accumulator100ms);
                accumulator100ms = 0f;
            }
            
            // 500msæ›´æ–° (2fps)
            accumulator500ms += deltaTime;
            if (accumulator500ms >= 0.5f)
            {
                UpdateBucket(UpdateFrequency.Every500ms, accumulator500ms);
                accumulator500ms = 0f;
            }
        }
        
        private void UpdateBucket(UpdateFrequency frequency, float deltaTime)
        {
            var bucket = frequencyBuckets[(int)frequency];
            foreach (var container in bucket)
            {
                container.Update(deltaTime);
            }
        }
    }
}
```

---

## Phase 3: å¼€å‘è€…å·¥å…·é“¾

### ğŸŸ¡ 3.1 å¯è§†åŒ–è°ƒè¯•çª—å£

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-4å¤©  
**å½±å“èŒƒå›´ï¼š** Editoræ–‡ä»¶å¤¹  
**çŠ¶æ€ï¼š** â¬œ å¾…å®Œæˆ

#### åŠŸèƒ½æ¸…å•

```csharp
#if UNITY_EDITOR
// =====================================================
// Editor/BuffSystemDebugger.cs
// =====================================================
using UnityEditor;
using UnityEngine;
using BuffSystem.Runtime;

namespace BuffSystem.Editor
{
    /// <summary>
    /// Buffç³»ç»Ÿè°ƒè¯•çª—å£
    /// </summary>
    public class BuffSystemDebugger : EditorWindow
    {
        [MenuItem("Window/BuffSystem/Debugger")]
        public static void ShowWindow()
        {
            GetWindow<BuffSystemDebugger>("Buff Debugger");
        }
        
        private Vector2 scrollPosition;
        private BuffOwner selectedOwner;
        private int selectedBuffId;
        
        private void OnGUI()
        {
            EditorGUILayout.LabelField("Buff System Debugger", EditorStyles.boldLabel);
            EditorGUILayout.Space();
            
            // å…¨å±€ç»Ÿè®¡
            DrawGlobalStats();
            
            EditorGUILayout.Space();
            
            // BuffOwneråˆ—è¡¨
            DrawOwnerList();
            
            EditorGUILayout.Space();
            
            // Buffè¯¦æƒ…
            if (selectedOwner != null)
            {
                DrawBuffDetails();
            }
            
            EditorGUILayout.Space();
            
            // æ‰‹åŠ¨æ“ä½œ
            DrawManualOperations();
        }
        
        private void DrawGlobalStats()
        {
            EditorGUILayout.LabelField("å…¨å±€ç»Ÿè®¡", EditorStyles.boldLabel);
            
            var owners = BuffOwner.AllOwners;
            int totalBuffs = 0;
            foreach (var owner in owners)
            {
                totalBuffs += owner.BuffCount;
            }
            
            EditorGUILayout.LabelField($"æ´»è·ƒOwneræ•°é‡: {owners.Count}");
            EditorGUILayout.LabelField($"æ€»Buffæ•°é‡: {totalBuffs}");
            EditorGUILayout.LabelField($"å¹³å‡æ¯Owner Buffæ•°: {(owners.Count > 0 ? totalBuffs / owners.Count : 0)}");
        }
        
        private void DrawOwnerList()
        {
            EditorGUILayout.LabelField("Buff Owners", EditorStyles.boldLabel);
            
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(200));
            
            foreach (var owner in BuffOwner.AllOwners)
            {
                bool isSelected = selectedOwner == owner;
                GUIStyle style = isSelected ? EditorStyles.selectionRect : EditorStyles.label;
                
                if (GUILayout.Button($"{owner.OwnerName} ({owner.BuffCount} buffs)", style))
                {
                    selectedOwner = owner;
                    Selection.activeGameObject = owner.gameObject;
                }
            }
            
            EditorGUILayout.EndScrollView();
        }
        
        private void DrawBuffDetails()
        {
            EditorGUILayout.LabelField($"{selectedOwner.OwnerName} çš„Buff", EditorStyles.boldLabel);
            
            foreach (var buff in selectedOwner.BuffContainer.AllBuffs)
            {
                EditorGUILayout.BeginVertical(GUI.skin.box);
                
                EditorGUILayout.LabelField($"{buff.Name} (ID: {buff.DataId})");
                EditorGUILayout.LabelField($"å±‚æ•°: {buff.CurrentStack}/{buff.MaxStack}");
                EditorGUILayout.LabelField($"å‰©ä½™æ—¶é—´: {buff.RemainingTime:F1}s");
                
                EditorGUILayout.BeginHorizontal();
                if (GUILayout.Button("+å±‚"))
                {
                    buff.AddStack(1);
                }
                if (GUILayout.Button("-å±‚"))
                {
                    buff.RemoveStack(1);
                }
                if (GUILayout.Button("åˆ·æ–°"))
                {
                    buff.RefreshDuration();
                }
                if (GUILayout.Button("ç§»é™¤", GUILayout.Width(60)))
                {
                    buff.MarkForRemoval();
                }
                EditorGUILayout.EndHorizontal();
                
                EditorGUILayout.EndVertical();
                EditorGUILayout.Space();
            }
        }
        
        private void DrawManualOperations()
        {
            EditorGUILayout.LabelField("æ‰‹åŠ¨æ“ä½œ", EditorStyles.boldLabel);
            
            selectedBuffId = EditorGUILayout.IntField("Buff ID", selectedBuffId);
            
            EditorGUILayout.BeginHorizontal();
            if (GUILayout.Button("æ·»åŠ Buff") && selectedOwner != null)
            {
                BuffApi.AddBuff(selectedBuffId, selectedOwner);
            }
            if (GUILayout.Button("æ¸…é™¤æ‰€æœ‰Buff") && selectedOwner != null)
            {
                selectedOwner.BuffContainer.ClearAllBuffs();
            }
            EditorGUILayout.EndHorizontal();
        }
    }
}
#endif
```

---

### ğŸŸ¡ 3.2 å®Œæ•´ç¤ºä¾‹é¡¹ç›®

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 4-5å¤©  
**å½±å“èŒƒå›´ï¼š** Samplesæ–‡ä»¶å¤¹  
**çŠ¶æ€ï¼š** â¬œ å¾…å®Œæˆ

#### ç¤ºä¾‹æ¸…å•

```
Samples/
â”œâ”€â”€ 01-BasicUsage/              # åŸºç¡€ä½¿ç”¨ç¤ºä¾‹
â”‚   â”œâ”€â”€ Scenes/
â”‚   â”‚   â””â”€â”€ BasicUsage.unity
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ SimpleBuffDemo.cs
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â””â”€â”€ Documentation/
â”‚       â””â”€â”€ BasicUsage.md
â”‚
â”œâ”€â”€ 02-RPGSystem/               # RPGæ¸¸æˆç¤ºä¾‹
â”‚   â”œâ”€â”€ Scenes/
â”‚   â”‚   â””â”€â”€ RPGDemo.unity
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ RPGPlayer.cs
â”‚   â”‚   â”œâ”€â”€ RPGAttributes.cs
â”‚   â”‚   â”œâ”€â”€ RPGBuffEffects.cs
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ Prefabs/
â”‚   â”‚   â””â”€â”€ RPGPlayer.prefab
â”‚   â””â”€â”€ Documentation/
â”‚       â””â”€â”€ RPGSystem.md
â”‚
â”œâ”€â”€ 03-MOBASystem/              # MOBAæ¸¸æˆç¤ºä¾‹
â”‚   â”œâ”€â”€ Scenes/
â”‚   â”‚   â””â”€â”€ MOBADemo.unity
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ MOBAHero.cs
â”‚   â”‚   â”œâ”€â”€ MOBASkills.cs
â”‚   â”‚   â”œâ”€â”€ MOBABuffSystem.cs
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â””â”€â”€ Documentation/
â”‚       â””â”€â”€ MOBASystem.md
â”‚
â”œâ”€â”€ 04-RoguelikeSystem/         # Roguelikeç¤ºä¾‹
â”‚   â”œâ”€â”€ Scenes/
â”‚   â”‚   â””â”€â”€ RoguelikeDemo.unity
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ RoguelikePlayer.cs
â”‚   â”‚   â”œâ”€â”€ RelicSystem.cs
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â””â”€â”€ Documentation/
â”‚       â””â”€â”€ RoguelikeSystem.md
â”‚
â”œâ”€â”€ 05-Networking/              # ç½‘ç»œåŒæ­¥ç¤ºä¾‹
â”‚   â”œâ”€â”€ Scenes/
â”‚   â”‚   â””â”€â”€ NetworkDemo.unity
â”‚   â”œâ”€â”€ Scripts/
â”‚   â”‚   â”œâ”€â”€ NetworkPlayer.cs
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â””â”€â”€ Documentation/
â”‚       â””â”€â”€ Networking.md
â”‚
â””â”€â”€ README.md
```

---

## ä¼˜åŒ–å®æ–½æ£€æŸ¥æ¸…å•

### Phase 1: æ ¸å¿ƒåŠŸèƒ½æ°¸ä¹…åŒ–

- [x] 1.1 æ ¸å¿ƒAPIå†»ç»“
  - [x] 1.1.1 æ ‡è®°æ°¸ä¹…ç¨³å®šæ¥å£
  - [ ] 1.1.2 åˆ›å»ºå…¼å®¹æ€§ä¿è¯æ–‡æ¡£
  - [ ] 1.1.3 ç¼–å†™APIç¨³å®šæ€§è§„èŒƒ
- [x] 1.2 Buffä¼ æ’­ç³»ç»Ÿ
  - [x] 1.2.1 IBuffTransmissibleæ¥å£
  - [x] 1.2.2 ContactTransmissionå®ç°
  - [x] 1.2.3 ChainTransmissionå®ç°
  - [x] 1.2.4 TransmissionManagerå®ç°
- [x] 1.3 Buffèåˆç³»ç»Ÿ
  - [x] 1.3.1 IBuffFusionæ¥å£
  - [x] 1.3.2 FusionRecipeç³»ç»Ÿ
  - [x] 1.3.3 FusionManagerå®ç°

### Phase 2: æ€§èƒ½æè‡´ä¼˜åŒ–

- [x] 2.1 ç»“æ„ä½“åŒ–æ”¹é€ 
  - [x] 2.1.1 BuffDataç»“æ„ä½“è®¾è®¡
  - [x] 2.1.2 BuffContainerOptimizedå®ç°
  - [ ] 2.1.3 NativeArrayé›†æˆ
  - [x] 2.1.4 å…¼å®¹å±‚ä¿æŒ
- [x] 2.2 åˆ†å±‚æ›´æ–°é¢‘ç‡
  - [x] 2.2.1 UpdateFrequencyæšä¸¾
  - [x] 2.2.2 FrequencyBasedUpdaterå®ç°
  - [ ] 2.2.3 è‡ªåŠ¨é¢‘ç‡åˆ†é…
- [ ] 2.3 æ€§èƒ½æµ‹è¯•éªŒè¯
  - [ ] 2.3.1 åŸºå‡†æµ‹è¯•
  - [ ] 2.3.2 å¯¹æ¯”æŠ¥å‘Š

### Phase 3: å¼€å‘è€…å·¥å…·é“¾

- [ ] 3.1 å¯è§†åŒ–è°ƒè¯•çª—å£
  - [ ] 3.1.1 BuffSystemDebuggerçª—å£
  - [ ] 3.1.2 å®æ—¶ç»Ÿè®¡é¢æ¿
  - [ ] 3.1.3 æ‰‹åŠ¨æ“ä½œåŠŸèƒ½
- [ ] 3.2 å®Œæ•´ç¤ºä¾‹é¡¹ç›®
  - [ ] 3.2.1 BasicUsageç¤ºä¾‹
  - [ ] 3.2.2 RPGSystemç¤ºä¾‹
  - [ ] 3.2.3 MOBASystemç¤ºä¾‹
  - [ ] 3.2.4 RoguelikeSystemç¤ºä¾‹
  - [ ] 3.2.5 Networkingç¤ºä¾‹
- [ ] 3.3 æ–‡æ¡£å®Œå–„
  - [ ] 3.3.1 é«˜çº§ç‰¹æ€§æ–‡æ¡£
  - [ ] 3.3.2 æ€§èƒ½ä¼˜åŒ–æŒ‡å—
  - [ ] 3.3.3 è¿ç§»æŒ‡å—

---

## ç‰ˆæœ¬å‘å¸ƒè®¡åˆ’

### v6.0.0 - æ ¸å¿ƒç¨³å®šç‰ˆ

**å‘å¸ƒæ—¶é—´ï¼š** Phase 1å®Œæˆå  
**ä¸»è¦å†…å®¹ï¼š**
- æ ¸å¿ƒAPIå†»ç»“
- Buffä¼ æ’­ç³»ç»Ÿ
- Buffèåˆç³»ç»Ÿ

### v6.1.0 - æ€§èƒ½ä¼˜åŒ–ç‰ˆ

**å‘å¸ƒæ—¶é—´ï¼š** Phase 2å®Œæˆå  
**ä¸»è¦å†…å®¹ï¼š**
- ç»“æ„ä½“åŒ–æ”¹é€ 
- åˆ†å±‚æ›´æ–°é¢‘ç‡
- æ€§èƒ½æå‡60%+

### v6.2.0 - å¼€å‘è€…ä½“éªŒç‰ˆ

**å‘å¸ƒæ—¶é—´ï¼š** Phase 3å®Œæˆå  
**ä¸»è¦å†…å®¹ï¼š**
- å¯è§†åŒ–è°ƒè¯•çª—å£
- 5+å®Œæ•´ç¤ºä¾‹é¡¹ç›®
- å®Œå–„æ–‡æ¡£

### v6.x ç»´æŠ¤è®¡åˆ’

- **v6.x.x Patchç‰ˆæœ¬**ï¼šBugä¿®å¤
- **å‘åå…¼å®¹ä¿è¯**ï¼šv6.0+ APIä¸å˜
- **æ‰©å±•åŠŸèƒ½**ï¼šé€šè¿‡æ–°æ¥å£æ·»åŠ 

---

**æ–‡æ¡£ç»“æŸ**
