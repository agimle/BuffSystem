# BuffSystem æ¨èä¼˜åŒ–æµç¨‹ v1.0

**æ–‡æ¡£ç‰ˆæœ¬ï¼š** v1.0  
**æ›´æ–°æ—¥æœŸï¼š** 2026-02-10  
**é€‚ç”¨èŒƒå›´ï¼š** BuffSystem v1.x ç‰ˆæœ¬ä¼˜åŒ–

---

## ç›®å½•

1. [ä¼˜åŒ–æ€»è§ˆ](#ä¼˜åŒ–æ€»è§ˆ)
2. [Phase 1: æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–](#phase-1-æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–)
3. [Phase 2: åŠŸèƒ½å¢å¼º](#phase-2-åŠŸèƒ½å¢å¼º)
4. [Phase 3: é«˜çº§ç‰¹æ€§](#phase-3-é«˜çº§ç‰¹æ€§)
5. [Phase 4: å·¥å…·ä¸æ–‡æ¡£](#phase-4-å·¥å…·ä¸æ–‡æ¡£)
6. [ä¼˜åŒ–å®æ–½æ£€æŸ¥æ¸…å•](#ä¼˜åŒ–å®æ–½æ£€æŸ¥æ¸…å•)
7. [ç‰ˆæœ¬å‘å¸ƒè®¡åˆ’](#ç‰ˆæœ¬å‘å¸ƒè®¡åˆ’)

---

## ä¼˜åŒ–æ€»è§ˆ

### ä¼˜åŒ–ç›®æ ‡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BuffSystem ä¼˜åŒ–ç›®æ ‡                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ€§èƒ½ç›®æ ‡ï¼šæ”¯æŒ1000+ BuffåŒæ—¶è¿è¡Œï¼Œå¸§ç‡å½±å“<1ms              â”‚
â”‚  åŠŸèƒ½ç›®æ ‡ï¼šè¦†ç›–95%æ¸¸æˆç±»å‹çš„Bufféœ€æ±‚                         â”‚
â”‚  æ˜“ç”¨ç›®æ ‡ï¼šæ–°ç”¨æˆ·30åˆ†é’Ÿå†…ä¸Šæ‰‹ï¼ŒAPIå­¦ä¹ æˆæœ¬<10ä¸ª              â”‚
â”‚  ç¨³å®šç›®æ ‡ï¼šç”Ÿäº§ç¯å¢ƒé›¶å´©æºƒï¼Œå†…å­˜é›¶æ³„æ¼                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ä¼˜åŒ–è·¯çº¿å›¾

```
æ—¶é—´çº¿ï¼š
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º

Phase 1 (1-2å‘¨)    Phase 2 (2-3å‘¨)    Phase 3 (3-4å‘¨)    Phase 4 (1å‘¨)
   æ ¸å¿ƒæ€§èƒ½            åŠŸèƒ½å¢å¼º           é«˜çº§ç‰¹æ€§           å·¥å…·æ–‡æ¡£
     â–¼                  â–¼                 â–¼                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Batchæ›´æ–°â”‚        â”‚æ¡ä»¶ç³»ç»Ÿ â”‚        â”‚å¯è§†åŒ–å·¥å…·â”‚      â”‚å®Œæ•´æ–‡æ¡£â”‚
â”‚äº‹ä»¶é˜Ÿåˆ— â”‚   â†’    â”‚äº’æ–¥ç³»ç»Ÿ â”‚   â†’    â”‚æ€§èƒ½ç›‘æ§ â”‚  â†’   â”‚ç¤ºä¾‹é¡¹ç›®â”‚
â”‚å¯¹è±¡æ± ä¼˜ â”‚        â”‚æ ‡ç­¾ç³»ç»Ÿ â”‚        â”‚å­˜æ¡£ç³»ç»Ÿ â”‚      â”‚è§†é¢‘æ•™ç¨‹â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚å­˜æ¡£æ”¯æŒ â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Phase 1: æ ¸å¿ƒæ€§èƒ½ä¼˜åŒ–

### 1.1 Batchæ›´æ–°æœºåˆ¶å®ç°

**ä¼˜å…ˆçº§ï¼š** ğŸ”´ é«˜  
**é¢„ä¼°å·¥æ—¶ï¼š** 2-3å¤©  
**å½±å“èŒƒå›´ï¼š** `BuffSystemUpdater`, `BuffOwner`

#### å®ç°æ–¹æ¡ˆ

```csharp
// BuffSystemUpdater.cs ä¿®æ”¹
public class BuffSystemUpdater : MonoBehaviour
{
    [SerializeField] private int batchCount = 4; // æ¯å¸§æ›´æ–°çš„æ‰¹æ¬¡
    private int currentBatchIndex = 0;
    
    private void UpdateAllContainers(float deltaTime)
    {
        var config = BuffSystemConfig.Instance;
        
        if (config.BatchCount <= 1)
        {
            // ä¸åˆ†æ‰¹ï¼Œå…¨éƒ¨æ›´æ–°
            BuffOwner.UpdateAll(deltaTime);
        }
        else
        {
            // åˆ†æ‰¹æ›´æ–°
            BuffOwner.UpdateBatch(deltaTime, currentBatchIndex, config.BatchCount);
            currentBatchIndex = (currentBatchIndex + 1) % config.BatchCount;
        }
    }
}

// BuffOwner.cs æ–°å¢
internal static void UpdateBatch(float deltaTime, int batchIndex, int totalBatches)
{
    for (int i = batchIndex; i < allOwners.Count; i += totalBatches)
    {
        if (i < allOwners.Count && allOwners[i] != null)
        {
            allOwners[i].buffContainer?.Update(deltaTime);
        }
    }
}
```

#### é…ç½®æ›´æ–°

```csharp
// BuffSystemConfig.cs
[Header("æ‰¹å¤„ç†è®¾ç½®")]
[SerializeField] private bool enableBatchUpdate = false;
[SerializeField] private int batchCount = 4;
[SerializeField] private int batchThreshold = 100; // è¶…è¿‡æ­¤æ•°é‡å¯ç”¨åˆ†æ‰¹

public bool EnableBatchUpdate => enableBatchUpdate;
public int BatchThreshold => batchThreshold;
```

#### éªŒæ”¶æ ‡å‡†

- [ ] 1000ä¸ªBuffè¿è¡Œæ—¶ï¼ŒUpdateè€—æ—¶<1ms
- [ ] åˆ†æ‰¹æ›´æ–°ä¸å½±å“Buffé€»è¾‘æ­£ç¡®æ€§
- [ ] é…ç½®å¯åŠ¨æ€åˆ‡æ¢æ›´æ–°æ¨¡å¼

---

### 1.2 äº‹ä»¶é˜Ÿåˆ—åŒ–

**ä¼˜å…ˆçº§ï¼š** ğŸ”´ é«˜  
**é¢„ä¼°å·¥æ—¶ï¼š** 2-3å¤©  
**å½±å“èŒƒå›´ï¼š** `BuffEventSystem`, `BuffContainer`

#### é—®é¢˜åˆ†æ

```csharp
// å½“å‰é—®é¢˜ï¼šäº‹ä»¶åŒæ­¥è§¦å‘å¯èƒ½å¯¼è‡´è¿é”ååº”
BuffEventSystem.OnBuffAdded += (sender, e) => {
    // å¦‚æœè¿™é‡Œåˆæ·»åŠ Buffï¼Œå¯èƒ½å¼•å‘é€’å½’
    BuffApi.AddBuff(1002, e.Buff.Owner); // å±é™©ï¼
};
```

#### å®ç°æ–¹æ¡ˆ

```csharp
// BuffEventSystem.cs é‡æ„
public static class BuffEventSystem
{
    private static readonly Queue<EventQueueItem> eventQueue = new();
    private static bool isProcessingQueue = false;
    
    internal static void TriggerBuffAdded(IBuff buff)
    {
        eventQueue.Enqueue(new EventQueueItem(EventType.Added, buff));
        ProcessQueue();
    }
    
    private static void ProcessQueue()
    {
        if (isProcessingQueue) return;
        
        isProcessingQueue = true;
        while (eventQueue.Count > 0)
        {
            var item = eventQueue.Dequeue();
            DispatchEvent(item);
        }
        isProcessingQueue = false;
    }
    
    private static void DispatchEvent(EventQueueItem item)
    {
        switch (item.Type)
        {
            case EventType.Added:
                OnBuffAdded?.Invoke(null, new BuffAddedEventArgs(item.Buff));
                break;
            // ... å…¶ä»–äº‹ä»¶
        }
    }
}
```

#### éªŒæ”¶æ ‡å‡†

- [ ] äº‹ä»¶å¤„ç†ä¸­å¯å®‰å…¨æ·»åŠ /ç§»é™¤Buff
- [ ] äº‹ä»¶å¤„ç†é¡ºåºå¯é¢„æµ‹
- [ ] æ— æ€§èƒ½é€€åŒ–

---

### 1.3 å¯¹è±¡æ± é¢„çƒ­

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 1å¤©  
**å½±å“èŒƒå›´ï¼š** `BuffContainer`

#### å®ç°æ–¹æ¡ˆ

```csharp
// BuffContainer.cs æ–°å¢
public void Prewarm(int count)
{
    var tempList = new List<BuffEntity>();
    
    // é¢„å…ˆåˆ›å»ºå¯¹è±¡
    for (int i = 0; i < count; i++)
    {
        tempList.Add(buffPool.Get());
    }
    
    // ç«‹å³å½’è¿˜åˆ°æ± ä¸­
    foreach (var buff in tempList)
    {
        buffPool.Release(buff);
    }
    
    Debug.Log($"[BuffContainer] å¯¹è±¡æ± é¢„çƒ­å®Œæˆï¼Œé¢„åˆ†é… {count} ä¸ªå¯¹è±¡");
}

// BuffSystemConfig.cs æ–°å¢é…ç½®
[Header("é¢„çƒ­è®¾ç½®")]
[SerializeField] private bool prewarmOnInitialize = true;
[SerializeField] private int prewarmCount = 32;
```

---

## Phase 2: åŠŸèƒ½å¢å¼º

### 2.1 Buffæ¡ä»¶ç³»ç»Ÿ

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-4å¤©  
**å½±å“èŒƒå›´ï¼š** `BuffDataSO`, `BuffContainer`, æ–°å¢`IBuffCondition`

#### è®¾è®¡ç›®æ ‡

```
æ”¯æŒæ¡ä»¶ï¼š
- æ·»åŠ æ¡ä»¶ï¼šæ»¡è¶³æ¡ä»¶æ‰èƒ½æ·»åŠ Buff
- ç»´æŒæ¡ä»¶ï¼šä¸æ»¡è¶³æ—¶è‡ªåŠ¨ç§»é™¤Buff
- æ¿€æ´»æ¡ä»¶ï¼šBuffå­˜åœ¨ä½†ä¸ç”Ÿæ•ˆï¼Œæ»¡è¶³åç”Ÿæ•ˆ
```

#### æ¥å£è®¾è®¡

```csharp
// Core/IBuffCondition.cs
public interface IBuffCondition
{
    /// <summary>
    /// æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³
    /// </summary>
    bool Check(IBuffOwner owner, IBuffData data);
    
    /// <summary>
    /// æ¡ä»¶æè¿°ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    /// </summary>
    string Description { get; }
}

// å†…ç½®æ¡ä»¶å®ç°ç¤ºä¾‹
[Serializable]
public class HealthPercentCondition : IBuffCondition
{
    [SerializeField] private float minHealthPercent = 0f;
    [SerializeField] private float maxHealthPercent = 1f;
    
    public bool Check(IBuffOwner owner, IBuffData data)
    {
        if (owner is IAttributeOwner attrOwner)
        {
            float hpPercent = attrOwner.GetHealthPercent();
            return hpPercent >= minHealthPercent && hpPercent <= maxHealthPercent;
        }
        return true;
    }
    
    public string Description => $"ç”Ÿå‘½å€¼åœ¨ {minHealthPercent*100}% - {maxHealthPercent*100}%";
}
```

#### BuffDataSOæ‰©å±•

```csharp
// Data/BuffDataSO.cs æ–°å¢
[Header("æ¡ä»¶è®¾ç½®")]
[SerializeReference, SubclassSelector]
private List<IBuffCondition> addConditions = new();

[SerializeReference, SubclassSelector]
private List<IBuffCondition> maintainConditions = new();

public IReadOnlyList<IBuffCondition> AddConditions => addConditions;
public IReadOnlyList<IBuffCondition> MaintainConditions => maintainConditions;
```

#### BuffContainerä¿®æ”¹

```csharp
// Runtime/BuffContainer.cs
public IBuff AddBuff(IBuffData data, object source = null)
{
    // æ£€æŸ¥æ·»åŠ æ¡ä»¶
    foreach (var condition in data.AddConditions)
    {
        if (!condition.Check(Owner, data))
        {
            if (BuffSystemConfig.Instance.EnableDebugLog)
            {
                Debug.Log($"[BuffContainer] æ·»åŠ Buffå¤±è´¥ï¼Œæ¡ä»¶ä¸æ»¡è¶³: {condition.Description}");
            }
            return null;
        }
    }
    
    // ... åŸæœ‰é€»è¾‘
}

// Updateä¸­æ£€æŸ¥ç»´æŒæ¡ä»¶
public void Update(float deltaTime)
{
    foreach (var buff in buffByInstanceId.Values)
    {
        // æ£€æŸ¥ç»´æŒæ¡ä»¶
        foreach (var condition in buff.Data.MaintainConditions)
        {
            if (!condition.Check(Owner, buff.Data))
            {
                buff.MarkForRemoval();
                break;
            }
        }
        
        buff.Update(deltaTime);
        // ...
    }
    
    ProcessRemovalQueue();
}
```

---

### 2.2 Buffäº’æ–¥ä¸ä¾èµ–ç³»ç»Ÿ

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 2-3å¤©  
**å½±å“èŒƒå›´ï¼š** `BuffDataSO`, `BuffContainer`

#### è®¾è®¡ç›®æ ‡

```
äº’æ–¥ï¼šAå’ŒBä¸èƒ½åŒæ—¶å­˜åœ¨
- æ·»åŠ Aæ—¶ï¼Œå¦‚æœBå­˜åœ¨ï¼Œæ ¹æ®ä¼˜å…ˆçº§å†³å®šæ›¿æ¢æˆ–é˜»æ­¢

ä¾èµ–ï¼šAä¾èµ–äºB
- æ·»åŠ Aæ—¶ï¼Œå¦‚æœBä¸å­˜åœ¨ï¼Œè‡ªåŠ¨æ·»åŠ Bæˆ–é˜»æ­¢æ·»åŠ A
- Bè¢«ç§»é™¤æ—¶ï¼ŒAè‡ªåŠ¨ç§»é™¤
```

#### æ•°æ®ç»“æ„

```csharp
// Data/BuffDataSO.cs æ–°å¢
[Header("å…³ç³»è®¾ç½®")]
[SerializeField] private List<int> mutexBuffIds = new(); // äº’æ–¥Buff IDs
[SerializeField] private List<int> dependBuffIds = new(); // ä¾èµ–Buff IDs
[SerializeField] private MutexPriority mutexPriority = MutexPriority.ReplaceOthers;

public enum MutexPriority
{
    BlockNew,       // é˜»æ­¢æ–°Buffæ·»åŠ 
    ReplaceOthers,  // æ›¿æ¢å·²æœ‰Buff
    Coexist         // å…è®¸å…±å­˜ï¼ˆä»…æ ‡è®°å…³ç³»ï¼‰
}
```

#### å®ç°é€»è¾‘

```csharp
// Runtime/BuffContainer.cs
private IBuff HandleMutexAndDependency(IBuffData data, object source)
{
    // æ£€æŸ¥ä¾èµ–
    foreach (var dependId in data.DependBuffIds)
    {
        if (!HasBuff(dependId))
        {
            // è‡ªåŠ¨æ·»åŠ ä¾èµ–Buff
            var dependData = BuffDatabase.Instance.GetBuffData(dependId);
            if (dependData != null)
            {
                AddBuff(dependData, source);
            }
        }
    }
    
    // æ£€æŸ¥äº’æ–¥
    foreach (var mutexId in data.MutexBuffIds)
    {
        if (buffsByDataId.TryGetValue(mutexId, out var mutexBuffs))
        {
            switch (data.MutexPriority)
            {
                case MutexPriority.BlockNew:
                    return null; // é˜»æ­¢æ·»åŠ 
                    
                case MutexPriority.ReplaceOthers:
                    // ç§»é™¤äº’æ–¥Buff
                    for (int i = mutexBuffs.Count - 1; i >= 0; i--)
                    {
                        RemoveBuff(mutexBuffs[i]);
                    }
                    break;
                    
                case MutexPriority.Coexist:
                    // ä»…æ ‡è®°ï¼Œä¸åšå¤„ç†
                    break;
            }
        }
    }
    
    return CreateNewBuff(data, source);
}
```

---

### 2.3 Buffæ ‡ç­¾ç³»ç»Ÿ

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 2å¤©  
**å½±å“èŒƒå›´ï¼š** `BuffDataSO`, `BuffContainer`, `BuffApi`

#### æ¥å£è®¾è®¡

```csharp
// Data/BuffDataSO.cs æ–°å¢
[Header("æ ‡ç­¾")]
[SerializeField] private List<string> tags = new();

public IReadOnlyList<string> Tags => tags;
public bool HasTag(string tag) => tags.Contains(tag);
```

#### APIæ‰©å±•

```csharp
// Core/BuffApi.cs æ–°å¢
/// <summary>
/// æ ¹æ®æ ‡ç­¾è·å–æ‰€æœ‰Buff
/// </summary>
public static IEnumerable<IBuff> GetBuffsByTag(string tag, IBuffOwner target)
{
    return target?.BuffContainer?.AllBuffs
        .Where(b => b.Data.Tags.Contains(tag)) ?? Enumerable.Empty<IBuff>();
}

/// <summary>
/// æ ¹æ®æ ‡ç­¾ç§»é™¤Buff
/// </summary>
public static void RemoveBuffsByTag(string tag, IBuffOwner target)
{
    var buffsToRemove = GetBuffsByTag(tag, target).ToList();
    foreach (var buff in buffsToRemove)
    {
        RemoveBuff(buff);
    }
}

/// <summary>
/// æ˜¯å¦æ‹¥æœ‰æŒ‡å®šæ ‡ç­¾çš„Buff
/// </summary>
public static bool HasBuffWithTag(string tag, IBuffOwner target)
{
    return target?.BuffContainer?.AllBuffs
        .Any(b => b.Data.Tags.Contains(tag)) ?? false;
}
```

---

### 2.4 å­˜æ¡£æ”¯æŒ

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¡ ä¸­  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-4å¤©  
**å½±å“èŒƒå›´ï¼š** æ–°å¢`IBuffSerializable`, `BuffSaveData`, `BuffContainer`

#### æ•°æ®ç»“æ„

```csharp
// Data/BuffSaveData.cs
[Serializable]
public class BuffSaveData
{
    public int BuffId;
    public int CurrentStack;
    public float Duration;
    public int SourceId; // éœ€è¦å¤–éƒ¨æ˜ å°„
    public Dictionary<string, string> CustomData; // è‡ªå®šä¹‰æ•°æ®
}

[Serializable]
public class BuffOwnerSaveData
{
    public int OwnerId;
    public List<BuffSaveData> Buffs = new();
}
```

#### åºåˆ—åŒ–æ¥å£

```csharp
// Core/IBuffSerializable.cs
public interface IBuffSerializable
{
    /// <summary>
    /// åºåˆ—åŒ–ä¸ºå­˜æ¡£æ•°æ®
    /// </summary>
    void Serialize(BuffSaveData saveData);
    
    /// <summary>
    /// ä»å­˜æ¡£æ•°æ®ååºåˆ—åŒ–
    /// </summary>
    void Deserialize(BuffSaveData saveData);
}

// BuffLogicBase.cs æ‰©å±•
public abstract class BuffLogicBase : IBuffLogic, ICloneable, IBuffSerializable
{
    public virtual void Serialize(BuffSaveData saveData) { }
    public virtual void Deserialize(BuffSaveData saveData) { }
}
```

#### å­˜æ¡£ç®¡ç†å™¨

```csharp
// Runtime/BuffSaveManager.cs
public static class BuffSaveManager
{
    /// <summary>
    /// ä¿å­˜æ‰€æœ‰BuffæŒæœ‰è€…çš„çŠ¶æ€
    /// </summary>
    public static List<BuffOwnerSaveData> SaveAll()
    {
        var result = new List<BuffOwnerSaveData>();
        
        foreach (var owner in BuffOwner.AllOwners)
        {
            if (owner != null)
            {
                result.Add(SaveOwner(owner));
            }
        }
        
        return result;
    }
    
    /// <summary>
    /// ä¿å­˜å•ä¸ªæŒæœ‰è€…çš„BuffçŠ¶æ€
    /// </summary>
    public static BuffOwnerSaveData SaveOwner(IBuffOwner owner)
    {
        var saveData = new BuffOwnerSaveData { OwnerId = owner.OwnerId };
        
        foreach (var buff in owner.BuffContainer.AllBuffs)
        {
            var buffSaveData = new BuffSaveData
            {
                BuffId = buff.DataId,
                CurrentStack = buff.CurrentStack,
                Duration = buff.Duration,
                SourceId = buff.SourceId
            };
            
            // åºåˆ—åŒ–è‡ªå®šä¹‰æ•°æ®
            if (buff.Data.CreateLogic() is IBuffSerializable serializable)
            {
                serializable.Serialize(buffSaveData);
            }
            
            saveData.Buffs.Add(buffSaveData);
        }
        
        return saveData;
    }
    
    /// <summary>
    /// åŠ è½½BuffçŠ¶æ€åˆ°æŒæœ‰è€…
    /// </summary>
    public static void LoadOwner(IBuffOwner owner, BuffOwnerSaveData saveData)
    {
        // å…ˆæ¸…ç©ºç°æœ‰Buff
        owner.BuffContainer.ClearAllBuffs();
        
        foreach (var buffData in saveData.Buffs)
        {
            var data = BuffDatabase.Instance.GetBuffData(buffData.BuffId);
            if (data == null) continue;
            
            // åˆ›å»ºBuffå¹¶æ¢å¤çŠ¶æ€
            var buff = owner.BuffContainer.AddBuff(data, null);
            if (buff is BuffEntity entity)
            {
                // é€šè¿‡åå°„æˆ–å†…éƒ¨æ–¹æ³•æ¢å¤çŠ¶æ€
                entity.RestoreState(buffData);
            }
        }
    }
}
```

---

## Phase 3: é«˜çº§ç‰¹æ€§

### 3.1 å¯è§†åŒ–è°ƒè¯•å·¥å…·

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¢ ä½  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-4å¤©  
**å½±å“èŒƒå›´ï¼š** æ–°å¢`BuffSystemDebugger`ç¼–è¾‘å™¨çª—å£

#### åŠŸèƒ½è®¾è®¡

```
BuffSystemè°ƒè¯•çª—å£
â”œâ”€â”€ å…¨å±€ç»Ÿè®¡
â”‚   â”œâ”€â”€ æ€»Buffæ•°é‡
â”‚   â”œâ”€â”€ æ´»è·ƒæŒæœ‰è€…æ•°é‡
â”‚   â”œâ”€â”€ å¯¹è±¡æ± çŠ¶æ€
â”‚   â””â”€â”€ äº‹ä»¶è§¦å‘é¢‘ç‡
â”œâ”€â”€ Buffåˆ—è¡¨
â”‚   â”œâ”€â”€ æŒ‰æŒæœ‰è€…ç­›é€‰
â”‚   â”œâ”€â”€ æŒ‰BuffIDç­›é€‰
â”‚   â”œâ”€â”€ å®æ—¶çŠ¶æ€æ˜¾ç¤º
â”‚   â””â”€â”€ æ‰‹åŠ¨æ·»åŠ /ç§»é™¤
â””â”€â”€ æ€§èƒ½ç›‘æ§
    â”œâ”€â”€ Updateè€—æ—¶
    â”œâ”€â”€ å†…å­˜å ç”¨
    â””â”€â”€ GCè§¦å‘æ¬¡æ•°
```

#### å®ç°æ¡†æ¶

```csharp
// Editor/BuffSystemDebugger.cs
#if UNITY_EDITOR
public class BuffSystemDebugger : EditorWindow
{
    [MenuItem("Window/BuffSystem/Debugger")]
    public static void ShowWindow()
    {
        GetWindow<BuffSystemDebugger>("Buff Debugger");
    }
    
    private Vector2 scrollPosition;
    private IBuffOwner selectedOwner;
    
    private void OnGUI()
    {
        DrawGlobalStats();
        DrawOwnerList();
        DrawBuffList();
        DrawPerformanceStats();
    }
    
    private void DrawGlobalStats()
    {
        EditorGUILayout.LabelField("å…¨å±€ç»Ÿè®¡", EditorStyles.boldLabel);
        
        int totalBuffs = BuffOwner.AllOwners.Sum(o => o.BuffCount);
        EditorGUILayout.LabelField($"æ€»Buffæ•°é‡: {totalBuffs}");
        EditorGUILayout.LabelField($"æ´»è·ƒæŒæœ‰è€…: {BuffOwner.AllOwners.Count}");
    }
    
    // ... å…¶ä»–ç»˜åˆ¶æ–¹æ³•
}
#endif
```

---

### 3.2 æ€§èƒ½ç›‘æ§å™¨

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¢ ä½  
**é¢„ä¼°å·¥æ—¶ï¼š** 2å¤©  
**å½±å“èŒƒå›´ï¼š** æ–°å¢`BuffSystemProfiler`

```csharp
// Runtime/BuffSystemProfiler.cs
public static class BuffSystemProfiler
{
    private static readonly Stopwatch updateTimer = new();
    private static long totalUpdateTime;
    private static int updateCount;
    
    public static void BeginUpdate()
    {
        if (!BuffSystemConfig.Instance.EnableProfiling) return;
        updateTimer.Restart();
    }
    
    public static void EndUpdate()
    {
        if (!BuffSystemConfig.Instance.EnableProfiling) return;
        updateTimer.Stop();
        totalUpdateTime += updateTimer.ElapsedMilliseconds;
        updateCount++;
    }
    
    public static float AverageUpdateTime => 
        updateCount > 0 ? (float)totalUpdateTime / updateCount : 0f;
    
    public static void Reset()
    {
        totalUpdateTime = 0;
        updateCount = 0;
    }
}
```

---

### 3.3 å†…ç½®Effectåº“

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¢ ä½  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-5å¤©  
**å½±å“èŒƒå›´ï¼š** æ–°å¢`Effects`æ–‡ä»¶å¤¹

```csharp
// Effects/ModifyAttributeEffect.cs
[Serializable]
public class ModifyAttributeEffect : EffectBase
{
    [SerializeField] private string attributeName;
    [SerializeField] private float modifyValue;
    [SerializeField] private ModifyType modifyType;
    
    public override void Execute(IBuff buff)
    {
        if (buff.Owner is IAttributeOwner attrOwner)
        {
            float finalValue = modifyType switch
            {
                ModifyType.Add => modifyValue * buff.CurrentStack,
                ModifyType.Multiply => modifyValue,
                ModifyType.Set => modifyValue,
                _ => modifyValue
            };
            
            attrOwner.ModifyAttribute(attributeName, finalValue, modifyType);
        }
    }
    
    public override void Cancel(IBuff buff)
    {
        // è‡ªåŠ¨è¿˜åŸ
    }
}

// Effects/DamageOverTimeEffect.cs
[Serializable]
public class DamageOverTimeEffect : EffectBase, IBuffLogicUpdate
{
    [SerializeField] private float damagePerSecond;
    [SerializeField] private DamageType damageType;
    
    private float damageAccumulator;
    
    public void OnLogicUpdate(float deltaTime)
    {
        damageAccumulator += damagePerSecond * deltaTime * Buff.CurrentStack;
        
        if (damageAccumulator >= 1f)
        {
            int damage = Mathf.FloorToInt(damageAccumulator);
            damageAccumulator -= damage;
            
            if (Buff.Owner is IDamageable damageable)
            {
                damageable.TakeDamage(damage, damageType, Buff.Source);
            }
        }
    }
}

// Effects/HealOverTimeEffect.cs
// Effects/ShieldEffect.cs
// Effects/StatModifierEffect.cs
// ...
```

---

## Phase 4: å·¥å…·ä¸æ–‡æ¡£

### 4.1 ç¤ºä¾‹é¡¹ç›®

**ä¼˜å…ˆçº§ï¼š** ğŸŸ¢ ä½  
**é¢„ä¼°å·¥æ—¶ï¼š** 3-4å¤©

```
Samples/
â”œâ”€â”€ 01_BasicUsage/           # åŸºç¡€ä½¿ç”¨ç¤ºä¾‹
â”‚   â”œâ”€â”€ SimpleBuffExample.cs
â”‚   â””â”€â”€ SimpleBuffScene.unity
â”œâ”€â”€ 02_RPG_Example/          # RPGæ¸¸æˆç¤ºä¾‹
â”‚   â”œâ”€â”€ CharacterStats.cs
â”‚   â”œâ”€â”€ BuffEffects/
â”‚   â””â”€â”€ RPG_Demo.unity
â”œâ”€â”€ 03_MOBA_Example/         # MOBAæ¸¸æˆç¤ºä¾‹
â”‚   â”œâ”€â”€ SkillSystem.cs
â”‚   â”œâ”€â”€ BuffSystem_Integration.cs
â”‚   â””â”€â”€ MOBA_Demo.unity
â””â”€â”€ 04_TurnBased_Example/    # å›åˆåˆ¶ç¤ºä¾‹
    â”œâ”€â”€ TurnManager.cs
    â””â”€â”€ TurnBased_Demo.unity
```

### 4.2 è§†é¢‘æ•™ç¨‹å¤§çº²

1. **å…¥é—¨ç¯‡** (10åˆ†é’Ÿ)
   - BuffSystemç®€ä»‹
   - å¿«é€Ÿå¼€å§‹
   - åˆ›å»ºç¬¬ä¸€ä¸ªBuff

2. **è¿›é˜¶ç¯‡** (20åˆ†é’Ÿ)
   - è‡ªå®šä¹‰Buffé€»è¾‘
   - äº‹ä»¶ç³»ç»Ÿä½¿ç”¨
   - å åŠ ç­–ç•¥é…ç½®

3. **å®æˆ˜ç¯‡** (30åˆ†é’Ÿ)
   - RPGæ¸¸æˆé›†æˆ
   - ä¸å±æ€§ç³»ç»Ÿé…åˆ
   - æ€§èƒ½ä¼˜åŒ–æŠ€å·§

---

## ä¼˜åŒ–å®æ–½æ£€æŸ¥æ¸…å•

### Phase 1 æ£€æŸ¥æ¸…å•

- [ ] Batchæ›´æ–°æœºåˆ¶å®ç°
  - [ ] BuffSystemUpdaterä¿®æ”¹
  - [ ] BuffOwner.UpdateBatchå®ç°
  - [ ] é…ç½®é¡¹æ·»åŠ 
  - [ ] æ€§èƒ½æµ‹è¯•é€šè¿‡
  
- [ ] äº‹ä»¶é˜Ÿåˆ—åŒ–
  - [ ] EventQueueItemå®šä¹‰
  - [ ] é˜Ÿåˆ—å¤„ç†é€»è¾‘
  - [ ] çº¿ç¨‹å®‰å…¨éªŒè¯
  - [ ] è¾¹ç•Œæµ‹è¯•
  
- [ ] å¯¹è±¡æ± é¢„çƒ­
  - [ ] Prewarmæ–¹æ³•å®ç°
  - [ ] é…ç½®é›†æˆ
  - [ ] å¯åŠ¨æ—¶è‡ªåŠ¨é¢„çƒ­

### Phase 2 æ£€æŸ¥æ¸…å•

- [ ] Buffæ¡ä»¶ç³»ç»Ÿ
  - [ ] IBuffConditionæ¥å£
  - [ ] å†…ç½®æ¡ä»¶å®ç°
  - [ ] BuffDataSOæ‰©å±•
  - [ ] Containeré€»è¾‘ä¿®æ”¹
  - [ ] æµ‹è¯•ç”¨ä¾‹
  
- [ ] äº’æ–¥ä¾èµ–ç³»ç»Ÿ
  - [ ] æ•°æ®ç»“æ„å®šä¹‰
  - [ ] æ·»åŠ é€»è¾‘ä¿®æ”¹
  - [ ] ç§»é™¤è”åŠ¨é€»è¾‘
  - [ ] å¾ªç¯ä¾èµ–æ£€æµ‹
  
- [ ] æ ‡ç­¾ç³»ç»Ÿ
  - [ ] æ•°æ®å±‚æ‰©å±•
  - [ ] APIå®ç°
  - [ ] æ‰¹é‡æ“ä½œæµ‹è¯•
  
- [ ] å­˜æ¡£æ”¯æŒ
  - [ ] æ•°æ®ç»“æ„å®šä¹‰
  - [ ] åºåˆ—åŒ–æ¥å£
  - [ ] SaveManagerå®ç°
  - [ ] å­˜æ¡£/è¯»æ¡£æµ‹è¯•

### Phase 3 æ£€æŸ¥æ¸…å•

- [ ] å¯è§†åŒ–è°ƒè¯•å·¥å…·
  - [ ] ç¼–è¾‘å™¨çª—å£
  - [ ] å®æ—¶æ•°æ®æ˜¾ç¤º
  - [ ] æ‰‹åŠ¨æ“ä½œåŠŸèƒ½
  
- [ ] æ€§èƒ½ç›‘æ§
  - [ ] Profilerå®ç°
  - [ ] æ•°æ®ç»Ÿè®¡
  - [ ] å¯è§†åŒ–å±•ç¤º
  
- [ ] å†…ç½®Effectåº“
  - [ ] å¸¸ç”¨Effectå®ç°
  - [ ] æ–‡æ¡£è¯´æ˜
  - [ ] ä½¿ç”¨ç¤ºä¾‹

### Phase 4 æ£€æŸ¥æ¸…å•

- [ ] ç¤ºä¾‹é¡¹ç›®
  - [ ] åŸºç¡€ç¤ºä¾‹
  - [ ] RPGç¤ºä¾‹
  - [ ] MOBAç¤ºä¾‹
  - [ ] å›åˆåˆ¶ç¤ºä¾‹
  
- [ ] æ–‡æ¡£å®Œå–„
  - [ ] APIæ–‡æ¡£æ›´æ–°
  - [ ] æ•™ç¨‹æ›´æ–°
  - [ ] è§†é¢‘æ•™ç¨‹åˆ¶ä½œ

---

## ç‰ˆæœ¬å‘å¸ƒè®¡åˆ’

### v1.1.0 - æ€§èƒ½ä¼˜åŒ–ç‰ˆ

**å‘å¸ƒæ—¶é—´ï¼š** Phase 1å®Œæˆå  
**ä¸»è¦æ›´æ–°ï¼š**
- Batchæ›´æ–°æœºåˆ¶
- äº‹ä»¶é˜Ÿåˆ—åŒ–
- å¯¹è±¡æ± é¢„çƒ­

### v1.2.0 - åŠŸèƒ½å¢å¼ºç‰ˆ

**å‘å¸ƒæ—¶é—´ï¼š** Phase 2å®Œæˆå  
**ä¸»è¦æ›´æ–°ï¼š**
- Buffæ¡ä»¶ç³»ç»Ÿ
- äº’æ–¥ä¾èµ–ç³»ç»Ÿ
- æ ‡ç­¾ç³»ç»Ÿ
- å­˜æ¡£æ”¯æŒ

### v1.3.0 - å·¥å…·å®Œå–„ç‰ˆ

**å‘å¸ƒæ—¶é—´ï¼š** Phase 3-4å®Œæˆå  
**ä¸»è¦æ›´æ–°ï¼š**
- å¯è§†åŒ–è°ƒè¯•å·¥å…·
- æ€§èƒ½ç›‘æ§å™¨
- å†…ç½®Effectåº“
- å®Œæ•´ç¤ºä¾‹é¡¹ç›®

---

## é™„å½•

### A. å‚è€ƒèµ„æ–™

- [Unity ObjectPoolæ–‡æ¡£](https://docs.unity3d.com/ScriptReference/Pool.ObjectPool_1.html)
- [æ¸¸æˆç¼–ç¨‹æ¨¡å¼](https://gameprogrammingpatterns.com/)
- [Unityæ€§èƒ½ä¼˜åŒ–æŒ‡å—](https://docs.unity3d.com/Manual/PerformanceOverview.html)

### B. æœ¯è¯­è¡¨

| æœ¯è¯­ | è¯´æ˜ |
|------|------|
| Buff | çŠ¶æ€æ•ˆæœï¼Œå¯ä»¥æ˜¯å¢ç›Šæˆ–å‡ç›Š |
| Stack | å±‚æ•°ï¼ŒBuffçš„å åŠ è®¡æ•° |
| DOT | Damage Over Timeï¼ŒæŒç»­ä¼¤å®³ |
| HOT | Heal Over Timeï¼ŒæŒç»­æ²»ç–— |
| CC | Crowd Controlï¼Œæ§åˆ¶æ•ˆæœ |

---

**æ–‡æ¡£ç»´æŠ¤ï¼š** éšç‰ˆæœ¬æ›´æ–°åŒæ­¥ç»´æŠ¤  
**æœ€åæ›´æ–°ï¼š** 2026-02-10
